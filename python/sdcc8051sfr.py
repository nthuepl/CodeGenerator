'''
	This is the code part for modeling 8051 SFRs (without SFR
	definitions), with code generation using SDCC 8051.

	The definition part should be externalized, so that the same
	definition (dictionary) can be reused over different compilers.

	For this reason, this SFR class should not be used as a superclass,
	but instead, different 8051 chips (e.g., cc2540, nrf24e1, etc) should
	just instantiate this with the dictionary.  I suppose C language can
	be portable enough to be compiler independent.

  Strictly speaking, this models not only SFRs but also XREGs as TI
	does in xdata space.  There may be other mechanisms as well but we
	only support these for now.  Others may be added later.
	
	There are two levels of use: (1) read/write the register -- should
	be done in the context of MCU, (2) read/write a bit or slice.
	This file includes just SFR and can do (2).  The class here is meant
	to be accessed in context of an MCU, rather than in isolation.
'''
from cc_sdcc8051 import CC_SDCC8051 as CodeCapsule

class SDCC8051SFR:  # instead of CC2540SFR or nRF24E1SFR
	'''
		This class CC2540SFR is just a container for two static hash
		tables of hash tables of stuff to provide the SFR definitions:
		one for all the SFRs and one for XREG.
	'''
	def __init__(self, chipName, SFRdict, XREGdict={}, mcu=None):
		self._chipName = chipName
		self._SFR = SFRdict
		self._XREG = XREGdict
		self._mcu = mcu


	def sanityCheck(self):
		# do a sanity check
		# extract all field names and sort and list them.
		SFRNames = self._SFR.keys()
		XREGNames = self._XREG.keys()
		#print sorted(SFRNames)

		SFRFieldSet = map(set, map(lambda x: self._SFR[x].keys(), SFRNames))
		XREGFieldSet = map(set, map(lambda x: self._XREG[x].keys(), XREGNames))
		# print sorted(SFRFieldSet)
		## now do a merge
		U = reduce(lambda x, y: x | y, SFRFieldSet+XREGFieldSet)
		print 'First level field names:', U
		## Go to the bitfield level

	def generateHeader(self, generatorName):
		# generate the header files for SFRs
		chipName = self._chipName
		fh = open('%ssfr.h' % chipName, 'w')
		fh.write('''/*
    %ssfr.h

    generated by %s
  */
#ifndef __%ssfr_h__
#define __%ssfr_h__
''' % (chipName, generatorName, chipName, chipName))

		lines = []
		SFRNames = self._SFR.keys()
		XREGNames = self._XREG.keys()
		bitfieldCount = 0
		print '%d SFRs, %d XREGs in definition' % (len(SFRNames), len(XREGNames))
		for sfr in SFRNames:
			if sfr[0] != '-':
				lines.append("__sfr __at (0x%x) %s;\n" % (self._SFR[sfr]['address'], sfr))
				if (self._SFR[sfr]['address'] % 8 == 0):
					if self._SFR[sfr].has_key('bitfields'):
						bitfields = self._SFR[sfr]['bitfields']
						for bf in bitfields.keys():
							# see if it slice is length 1. if so, declare as sbit
							if bf[0] != '-' and len(bitfields[bf]['slice']) == 1:
								bitfieldCount += 1
								lines.append("__sbit __at (0x%x) %s_%s;\n" %\
									(self._SFR[sfr]['address'] + bitfields[bf]['slice'][0], sfr, bf))
					# in addition, we generate the _n names for each bit that has
					# a bit address. e.g., P1_1 for P1.1
					for i in range(8):
						lines.append("__sbit __at (0x%x) %s_%d;\n" % \
								(self._SFR[sfr]['address'] + i, sfr, i))

		SFRsWritten = len(lines)
		for xreg in self._XREG.keys():
			if xreg[0] != '-' and not self._SFR.has_key(xreg):
				lines.append("__xdata __at (0x%04x) %s;\n" % (self._XREG[xreg]['address'], xreg))
		lines.sort()
		fh.writelines(lines)
		fh.write("#endif /* __%ssfr_h__ */\n" % chipName)
		print 'Created file %ssfr.h wrote %d SFRs, %d bitfields, %d XREGs. reserved ones not written' \
			% (chipName, SFRsWritten - bitfieldCount, bitfieldCount, len(lines)-SFRsWritten)
		fh.close()

class SFR:
	'''This is a ``factory'' that constructs the SFRs.
	  Each one is initialized to its default value.
		The behavior depends on its access previlege.

		20140226 PC:  This class is shared by different MCUs of 8051 ISA.
		This class is currently assuming SDCC, but most of it should
		probably be promoted to a base class for different
		compiler-specific SFR.
	'''
	def __init__(self, sfrName, sfrDefn, mcu=None):
		# we could do a copy, but for now let's save time and just use
		# reference.
		self.__dict__['_name']        = sfrName
		self.__dict__['_defn']        = sfrDefn
		self.__dict__['_address']     = sfrDefn['address']
		self.__dict__['_module']      = sfrDefn['module']
		self.__dict__['_description'] = sfrDefn['module']
		self.__dict__['_value']       = 0
		# self.__dict__['_C'] = 0
		# self.__dict__['_A'] = 0
		self.__dict__['_code'] = None
		self.__dict__['_mcu'] = mcu
		# initialize the value to the power-up default, if any.
		self.powerUpInit()

	def getVarType(self):
		return 'uint8'

	def powerUpInit(self):
		''' sets it to the default value locally.
		   The MCU side is initialized by hardware reset!
		'''
		self._value = 0
		if self._defn.has_key('default'):
			self._value = self._defn['default']
			return
		if not self._defn.has_key('bitfields'):
			# no initialization then
			return
		# otherwise, dig into each bit in the field. everything else is
		# initialized to 0.
		for field in self._defn['bitfields'].values():
			s = field['slice']
			val = field.get('default',0)
			if not isinstance(val, int):  # (type(val) != type(0)):
				raise TypeError("type of val of %s is %s", self._name, type(val))
			if (len(s) == 1):
				self._value |= (val & 1) << s[0]
			elif (len(s) == 2):
				j = 1 << s[1]
				for i in range(s[1], s[0]+1):
					self._value |= (val & j) << i
					j <<= 1
			else:
				## malformed slice. fail silently?
				raise ValueError("bad slice for SFR %s: %s" % (self_.name, s))

	def setattr(self, name, value):
		return self.__setattr__(name, value)

	def __setattr__(self, name, value):
		'''This is the dot-notation, used for setting a bit field or a
		slice in an SFR.  Python will give a syntax error if we do
		port.1 or dot-digit. so we need to make it an identifier by
		port._1 instead.  The value to set is in A, regardless if it is
		single bit.
		@@@ Should check write permission!?
		'''
		if self.__dict__.has_key(name):
			self.__dict__[name] = value
			return
			# regular attribute access, no return value
		if isinstance(value, CodeCapsule):
			self._code = value
		else:
			self._code = CodeCapsule(self._mcu, dest=self, src=self)
		if len(name) == 2 and name[0] == '_' and name[1] in '01234567':
			# special handling: as bit index
			bitindex = int(name[1])
			# print "bit index %d" % bitindex
			return self._writeBit(self._address, bitindex, value)

		# now look up name
		if not self._defn.has_key('bitfields') or \
				not self._defn['bitfields'].has_key(name):
			# uh oh... no bit name has been defined for it
			raise NameError("bit name `%s' not found in SFR `%s'" % (name, self._name))
		# need to determine slice size.
		# this should work. if no 'slice' entry then original definition
		# is malformed!!
		s = self._defn['bitfields'][name]['slice']
		if (len(s) == 1):
			# this is a bit access.
			return self._writeBit(self._address, s[0], value)
		# otherwise, we have a slice. read as a byte first,
		# then mask it and extract.
		elif (len(s) != 2):
			# if neither 1 or 2, then definition is malformed!
			raise NameError('malformed slice %s' % s)
		# To write, we first clear the slice with AND, then OR in the # bits.
		# construct the slice mask from bit s[0] downto s[1]
		# find out many bits wide, shift (1 << bitsWide) - 1
		# example. 2 bit wide: (1 << 2 = 4)-1 = 3 = 0b11
		# then, shift the mask up to s[1] position.
		# complement it to AND, then shift the value up to region and OR.
		p = s[1]
		mask = ((1 << (s[0]-p+1)) - 1) << p
		maskN = 0xff ^ mask  # complement the whole byte, nothing more.
		if (isinstance(value, int)):
			valMask = (value << p) & mask
			self._emit('(%s = (%s & 0x%x) | 0x%x)' % self.name(),
					self.name(), maskN, valMask)
			# self._SFRandByte(maskN)  # clear out the part we'll write in.
			# self._SFRorByte(valMask)
		elif (isinstance(value, CodeCapsule)):
			self._emit('(%s = (%s & 0x%x) | ((%s) << %d) & 0x%x)' %
					(self.name(), self.name(), maskN, value.getCode(), p, mask))
			# byte assumed already in A. need to shift left by s[1]
			# positions.
		return self._code


	def writeSFR(self, value):
		'''This is to write the SFR (by MOV instruction) 
		   We locally simulate this by writing _value.
		   Option: check write permission?
			 if address is over 0xff then it's an XREG. use MOVX.
		'''
		if value is None:
			return
		if isinstance(value, CodeCapsule):
			self._code = value
		else:
			self._code = CodeCapsule(self._mcu, dest=self,
					src=self)
		if (isinstance(value, SFR)):
			# either case the runtime already called value.readSFR() or
			# value.readVar() and put result into A.
			# now is time to write A back into SFR.
			# PC 20140221: if we include cc2540sfr.h that is generated by this file
			# then we can just use the name symbolically and not have to
			# worry about the address being higher or lower!
			self._emit('(%s = %s)' % (self.name(), value.name()))
		elif isinstance(value, CodeCapsule):
			self._emit('(%s = %s)' % (self.name(), value.getCode()))
		elif isinstance(value, int) or isinstance(value, str):
			if isinstance(value, str):
				if len(value) == 0:
					value = 0
				elif len(value) == 1:
					value = ord(value)
				else:
					raise ValueError('Cannot assign string %s to SFR %s' % (value,
						self._name))
			self._emit('(%s = 0x%x)' % (self.name(), value))
		else:
			raise Exception('writeSFR unsupported value %s' % value)
		self._value = value
		return self._code

	def getattr(self, name):
		return self.__getattr__(name)

	def __getattr__(self, name):
		'''This is the dot-notation, used for reading a bit field in an
		SFR.  Python will give a syntax error if we do port.1 or a
		dot-digit. so we need to make it an identifier by port._1 instead.
		Decide whether it is a read byte, read slice (done as a
		read-byte, followed by masking), or read bit operation.
		'''
		if self.__dict__.has_key(name):
			return self.__dict__[name]
		# print "sfr.__getattr__(%s)" % name
		if len(name) == 2 and name[0] == '_' and name[1] in '01234567':
			self._code = CodeCapsule(self._mcu, src=self,
					dest=self._mcu.lookupVar('C'))  # outlet is assumed to be accumulator?
			# special handling: as bit index
			bitindex = int(name[1])
			# If the SFR is bit addressable (i.e., modulo 8) then access
			# using a bit instruction. Otherwise, access as word and return
			# value.
			return self._readBit(self._address, bitindex)
		else:
			self._code = CodeCapsule(self._mcu, src=self,
					dest=self._mcu.lookupVar('A'))  # outlet is assumed to be accumulator?

		if not self._defn.has_key('bitfields') or \
				not self._defn['bitfields'].has_key(name):
			# uh oh... no bit name has been defined for it
			raise NameError("bit name `%s' not found in SFR `%s'" % (name, self._name))
		# need to determine slice size.
		# this should work. if no 'slice' entry then original definition
		# is malformed!!
		s = self._defn['bitfields'][name]['slice']
		if (len(s) == 1):
			# this is a bit access.
			return self._readBit(self._address, s[0], name)
		# otherwise, we have a slice. read as a byte first,
		# then mask it and extract.
		if (len(s) != 2):
			# if neither 1 or 2, then definition is malformed!
			raise NameError('malformed slice %s' % s)
		# Now, construct the mask from bit s[0] downto s[1]
		# find out many bits wide, shift (1 << bitsWide) - 1
		# example. 2 bit wide: (1 << 2 = 4)-1 = 3 = 0b11
		# then, shift the mask up to s[1] position.
		mask = ((1 << (s[0]-s[1]+1)) - 1) << s[1]
		self._emit('(uint8)(%s & 0x%x) >> %d' % (self._name, mask, s[1]))
		#self._loadByte(self._address)
		#self._AandByte(mask)
		# now shift right, using a combination of rotate and swap.
		# Because we already masked out the lower bits, rotate will not
		# cause problems.
		return self._code

	def _emit(self, formatStr, *operands):
		self._code.emit(formatStr, *operands)

	def _writeBit(self, address, bitindex, value):
		'''
			use either setb or clr if bit addressable,
			or use AND/OR trick
		'''
		self._code.setResultType('bool')
		if self._address % 8 != 0 or self._address > 0xff:
			# must AND or OR the mask byte depending on if 0 or 1.
			mask = (1 << bitindex)
			if (isinstance(value, int)): # maybe also allow string of '0''1'
				if (value == 0):
					# and with the bit cleared: invert mask
					mask ^= 0xff
					self._emit('(%s &= 0x%x)' % (self.name(), mask))
					# self._SFRandByte(mask)
					self._value &= mask
					return self._code
				elif (value == 1):
					# OR with the bit set
					self._emit('(%s |= 0x%x)' % (self.name(), mask))
					# self._SFRorByte(mask)
					self._value |= mask
					return self._code
				else:
					# value too large
					raise ValueError('value %d overflow for bit assignment' %
							value)
			else: # assume bit is in C
				# use the Rotate-through-C trick!
				# this could be more efficient than C unless we do bit fields...
				self._emit('(%s = (%s & 0x%x) | (%s << %d))' % (self.name(),
						self.name(), mask, value.getCode(), bitindex))
				return self._code

		else:  # modulo 8 => bit address is simply byte address + bitindex
			# use setb or clr
			if (isinstance(value, int)):
				if (value == 0):
					self._emit('(%s_%d = 0)' % (self.name(), bitindex))
					# self._emit('CLR 0x%x', (address+bitindex))
					self._value &= (0xff ^ (1 << bitindex))
					return self._code
				elif (value == 1):
					self._emit('(%s_%d = 1)' % (self.name(), bitindex))
					# self._emit('SETB 0x%x', (address+bitindex))
					self._value |= (1 << bitindex)
					return self._code
				else:
					# value too large
					raise ValueError('value %d overflow for bit assignment' %
							value)
			else: # assume bit is in C
				self._emit('(%s_%d = %s)' % (self.name(), bitindex, value.getCode()))
				# self._emit('MOV 0x%x, C', (address+bitindex))
				return self._code
		raise ValueError('binary value expected but %s given' % value)

	def _readBit(self, address, bitindex, bitname=None):
		'''uses either MOV byte and extract bit or MOV bit instruction to
			read the bit at address.bitindex from memory.
			If it is a multiple of 8 then it can use bit MOV instruction.
			otherwise, it must use byte MOV instruction and extract bit.
		'''
		if (address > 0xff) or (address % 8 != 0):
			# do byte access and extract bit
			self._emit('(bool)((%s >> %d) & 1)' % (self._name, bitindex))
			# self._loadByte(self._address) # this does it to memory with MOV
			# return self._extractBit(bitindex)  # save in bit accumulator C
			# was: return (self._value >> bitindex) & 1
		else:
			# the bit address is simply the byte address + bit index!
			# by 8051 convention.
			if bitname:
				self._emit('%s_%s' % (self._name, bitname))
			else:
				# actually, this conditional might not be necessary
				# since python will probably format %s for int correctly anyway
				self._emit('%s_%d' % (self._name, bitindex))
			# return self._loadBit(self._address + bitindex)
		self._code.setResultType('bool')
		return self._code



	def readSFR(self, dest=None):
		'''This is called by the mcu.SFR to generate instructions to
		   load from SFR as a byte. this is just an expression,
			 so it needs to be used somehow by someone else, 
			 possibly written to a global return buffer.
		'''
		if dest is None: dest = self._mcu.lookupVar('A')
		self._code = CodeCapsule(self._mcu, src=self, dest=dest)
		self._code.setResultType('uint8')
		self._emit('%s' % self.name())
		return self._code
		# return self._loadByte(self._address)


	def name(self):
		return self._name

	def __repr__(self):
		return str(self.__class__.__name__+"('"+self._name+"')")

	def __str__(self):
		return repr(self)

	#### making everything int compatible ####

	def __int__(self):
		return self._value

	def __hex__(self):
		return hex(self._value)

	# to do: (8/29)
	# - use [ ] operator for bit addressing?
	#   this can be viewed as alternative syntax for the dot notation?
	# - perhaps the function-call version?
	# - SFR "aliases": 
	#   example: AB  = A concatenated with B
	#   example: a lot of SFRs with the H and L (high and low)
	#   arbitrary variables
	#   => such an alias would not have one address!
  #   => probably should not handle as subclass of SFR?


	# any need for other operations? both evaluate locally and generate
	# code remotely?


