///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// IAR C/C++ Compiler V8.20.1.40829 for 8051            10/Jul/2014  13:44:13 /
// Copyright 2004-2012 IAR Systems AB.                                        /
//                                                                            /
//    Core               =  plain                                             /
//    Code model         =  banked                                            /
//    Data model         =  large                                             /
//    Calling convention =  xdata reentrant                                   /
//    Constant location  =  data_rom                                          /
//    Dptr setup         =  1,16                                              /
//                                                                            /
//    Source file        =  D:\NTHU\¬ã¨s\Important\ThesisCode\Code\GitLabClou /
//                          d\NewEcoExec\codegenerator\Device\EcoBT\Project\b /
//                          le\Profiles\Roles\gapbondmgr.c                    /
//    Command line       =  -f D:\NTHU\¬ã¨s\Important\ThesisCode\Code\GitLabC /
//                          loud\NewEcoExec\codegenerator\Device\EcoBT\Projec /
//                          t\ble\CodeGenerator\CC2541DB\..\..\config\buildCo /
//                          mponents.cfg (-DBROADCASTER_CFG=0x01              /
//                          -DOBSERVER_CFG=0x02 -DPERIPHERAL_CFG=0x04         /
//                          -DCENTRAL_CFG=0x08 -DADV_NCONN_CFG=0x01           /
//                          -DADV_CONN_CFG=0x02 -DSCAN_CFG=0x04               /
//                          -DINIT_CFG=0x08 -DADV_CFG=ADV_NCONN_CFG+ADV_CONN_ /
//                          CFG -DLINK_CFG=ADV_CONN_CFG+INIT_CFG              /
//                          -DFULL_CFG=INIT_CFG+SCAN_CFG+ADV_NCONN_CFG+ADV_CO /
//                          NN_CFG) -f D:\NTHU\¬ã¨s\Important\ThesisCode\Code /
//                          \GitLabCloud\NewEcoExec\codegenerator\Device\EcoB /
//                          T\Project\ble\CodeGenerator\CC2541DB\buildConfig. /
//                          cfg (-DHOST_CONFIG=PERIPHERAL_CFG                 /
//                          -DGAP_PRIVACY_RECONNECT -DCC2541                  /
//                          -DOAD_IMAGE_VERSION=0x0000                        /
//                          "-DOAD_IMAGE_A_USER_ID='A', 'A', 'A', 'A'"        /
//                          "-DOAD_IMAGE_B_USER_ID='B', 'B', 'B', 'B'")       /
//                          D:\NTHU\¬ã¨s\Important\ThesisCode\Code\GitLabClou /
//                          d\NewEcoExec\codegenerator\Device\EcoBT\Project\b /
//                          le\Profiles\Roles\gapbondmgr.c -D                 /
//                          INT_HEAP_LEN=900 -D HALNODEBUG -D                 /
//                          OSAL_CBTIMER_NUM_TASKS=1 -D HAL_AES_DMA=TRUE -D   /
//                          HAL_DMA=TRUE -D xPOWER_SAVING -D                  /
//                          xPLUS_BROADCASTER -D HAL_LCD=FALSE -D             /
//                          HAL_LED=TRUE -D HAL_ADC=TRUE -lB                  /
//                          D:\NTHU\¬ã¨s\Important\ThesisCode\Code\GitLabClou /
//                          d\NewEcoExec\codegenerator\Device\EcoBT\Project\b /
//                          le\CodeGenerator\CC2541DB\CC2541\List\ -o         /
//                          D:\NTHU\¬ã¨s\Important\ThesisCode\Code\GitLabClou /
//                          d\NewEcoExec\codegenerator\Device\EcoBT\Project\b /
//                          le\CodeGenerator\CC2541DB\CC2541\Obj\ -e --debug  /
//                          --core=plain --dptr=16,1 --data_model=large       /
//                          --code_model=banked --calling_convention=xdata_re /
//                          entrant --place_constants=data_rom                /
//                          --nr_virtual_regs 16 -I                           /
//                          D:\NTHU\¬ã¨s\Important\ThesisCode\Code\GitLabClou /
//                          d\NewEcoExec\codegenerator\Device\EcoBT\Project\b /
//                          le\CodeGenerator\CC2541DB\..\..\common\ -I        /
//                          D:\NTHU\¬ã¨s\Important\ThesisCode\Code\GitLabClou /
//                          d\NewEcoExec\codegenerator\Device\EcoBT\Project\b /
//                          le\CodeGenerator\CC2541DB\..\..\include\ -I       /
//                          D:\NTHU\¬ã¨s\Important\ThesisCode\Code\GitLabClou /
//                          d\NewEcoExec\codegenerator\Device\EcoBT\Project\b /
//                          le\CodeGenerator\CC2541DB\..\..\..\..\Components\ /
//                          hal\include\ -I D:\NTHU\¬ã¨s\Important\ThesisCode /
//                          \Code\GitLabCloud\NewEcoExec\codegenerator\Device /
//                          \EcoBT\Project\ble\CodeGenerator\CC2541DB\..\..\. /
//                          .\..\Components\hal\target\CC2540EB\ -I           /
//                          D:\NTHU\¬ã¨s\Important\ThesisCode\Code\GitLabClou /
//                          d\NewEcoExec\codegenerator\Device\EcoBT\Project\b /
//                          le\CodeGenerator\CC2541DB\..\..\..\..\Components\ /
//                          osal\include\ -I D:\NTHU\¬ã¨s\Important\ThesisCod /
//                          e\Code\GitLabCloud\NewEcoExec\codegenerator\Devic /
//                          e\EcoBT\Project\ble\CodeGenerator\CC2541DB\..\..\ /
//                          ..\..\Components\services\saddr\ -I               /
//                          D:\NTHU\¬ã¨s\Important\ThesisCode\Code\GitLabClou /
//                          d\NewEcoExec\codegenerator\Device\EcoBT\Project\b /
//                          le\CodeGenerator\CC2541DB\..\..\..\..\Components\ /
//                          ble\include\ -I D:\NTHU\¬ã¨s\Important\ThesisCode /
//                          \Code\GitLabCloud\NewEcoExec\codegenerator\Device /
//                          \EcoBT\Project\ble\CodeGenerator\CC2541DB\..\..\. /
//                          .\..\Components\ble\controller\phy\ -I            /
//                          D:\NTHU\¬ã¨s\Important\ThesisCode\Code\GitLabClou /
//                          d\NewEcoExec\codegenerator\Device\EcoBT\Project\b /
//                          le\CodeGenerator\CC2541DB\..\..\..\..\Components\ /
//                          ble\controller\include\ -I                        /
//                          D:\NTHU\¬ã¨s\Important\ThesisCode\Code\GitLabClou /
//                          d\NewEcoExec\codegenerator\Device\EcoBT\Project\b /
//                          le\CodeGenerator\CC2541DB\..\..\..\..\Components\ /
//                          ble\hci\ -I D:\NTHU\¬ã¨s\Important\ThesisCode\Cod /
//                          e\GitLabCloud\NewEcoExec\codegenerator\Device\Eco /
//                          BT\Project\ble\CodeGenerator\CC2541DB\..\..\..\.. /
//                          \Components\ble\host\ -I                          /
//                          D:\NTHU\¬ã¨s\Important\ThesisCode\Code\GitLabClou /
//                          d\NewEcoExec\codegenerator\Device\EcoBT\Project\b /
//                          le\CodeGenerator\CC2541DB\..\..\common\cc2540\    /
//                          -I D:\NTHU\¬ã¨s\Important\ThesisCode\Code\GitLabC /
//                          loud\NewEcoExec\codegenerator\Device\EcoBT\Projec /
//                          t\ble\CodeGenerator\CC2541DB\..\..\common\npi\npi /
//                          _np\ -I D:\NTHU\¬ã¨s\Important\ThesisCode\Code\Gi /
//                          tLabCloud\NewEcoExec\codegenerator\Device\EcoBT\P /
//                          roject\ble\CodeGenerator\CC2541DB\..\..\Profiles\ /
//                          Roles\ -I D:\NTHU\¬ã¨s\Important\ThesisCode\Code\ /
//                          GitLabCloud\NewEcoExec\codegenerator\Device\EcoBT /
//                          \Project\ble\CodeGenerator\CC2541DB\..\..\Profile /
//                          s\SimpleProfile\ -I D:\NTHU\¬ã¨s\Important\Thesis /
//                          Code\Code\GitLabCloud\NewEcoExec\codegenerator\De /
//                          vice\EcoBT\Project\ble\CodeGenerator\CC2541DB\..\ /
//                          ..\Profiles\DevInfo\ -I                           /
//                          D:\NTHU\¬ã¨s\Important\ThesisCode\Code\GitLabClou /
//                          d\NewEcoExec\codegenerator\Device\EcoBT\Project\b /
//                          le\CodeGenerator\CC2541DB\..\..\Profiles\Accelero /
//                          meter\ -I D:\NTHU\¬ã¨s\Important\ThesisCode\Code\ /
//                          GitLabCloud\NewEcoExec\codegenerator\Device\EcoBT /
//                          \Project\ble\CodeGenerator\CC2541DB\..\..\Profile /
//                          s\EcoExecGATTProfile\ -I                          /
//                          D:\NTHU\¬ã¨s\Important\ThesisCode\Code\GitLabClou /
//                          d\NewEcoExec\codegenerator\Device\EcoBT\Project\b /
//                          le\CodeGenerator\CC2541DB\..\..\Profiles\timeserv /
//                          ice\ -I D:\NTHU\¬ã¨s\Important\ThesisCode\Code\Gi /
//                          tLabCloud\NewEcoExec\codegenerator\Device\EcoBT\P /
//                          roject\ble\CodeGenerator\CC2541DB\..\..\Profiles\ /
//                          Batt\ -I D:\NTHU\¬ã¨s\Important\ThesisCode\Code\G /
//                          itLabCloud\NewEcoExec\codegenerator\Device\EcoBT\ /
//                          Project\ble\CodeGenerator\CC2541DB\..\..\Profiles /
//                          \HIDDev\ -I D:\NTHU\¬ã¨s\Important\ThesisCode\Cod /
//                          e\GitLabCloud\NewEcoExec\codegenerator\Device\Eco /
//                          BT\Project\ble\CodeGenerator\CC2541DB\..\..\Profi /
//                          les\ScanParam\ -Ohz                               /
//    List file          =  D:\NTHU\¬ã¨s\Important\ThesisCode\Code\GitLabClou /
//                          d\NewEcoExec\codegenerator\Device\EcoBT\Project\b /
//                          le\CodeGenerator\CC2541DB\CC2541\List\gapbondmgr. /
//                          s51                                               /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME gapbondmgr

        RSEG DOVERLAY:DATA:NOROOT(0)
        RSEG IOVERLAY:IDATA:NOROOT(0)
        RSEG ISTACK:IDATA:NOROOT(0)
        RSEG PSTACK:XDATA:NOROOT(0)
        RSEG XSTACK:XDATA:NOROOT(0)

        EXTERN ?ALLOC_XSTACK8
        EXTERN ?BANKED_ENTER_XDATA
        EXTERN ?BANKED_LEAVE_XDATA
        EXTERN ?BDISPATCH
        EXTERN ?BRET
        EXTERN ?CALL_IND
        EXTERN ?DEALLOC_XSTACK8
        EXTERN ?L_MOV_TO_X
        EXTERN ?L_MOV_X
        EXTERN ?MOVE_LONG8_XDATA_XDATA
        EXTERN ?PUSH_XSTACK8_X_TWO
        EXTERN ?PUSH_XSTACK_I_FOUR
        EXTERN ?PUSH_XSTACK_I_ONE
        EXTERN ?PUSH_XSTACK_I_TWO
        EXTERN ?S_DIV_MOD
        EXTERN ?S_SHL
        EXTERN ?UL_DIV_MOD
        EXTERN ?UL_GE_X
        EXTERN ?US_SWITCH_DENSE
        EXTERN ?V0
        EXTERN ?XLOAD_R2345
        EXTERN ?XSP
        EXTERN ?XSTACK_DISP0_8
        EXTERN ?XSTORE_R2345
        EXTERN __INIT_XDATA_I
        EXTERN __INIT_XDATA_Z

        PUBLIC ??GAPBondMgr_CheckNVLen?relay
        PUBLIC ??GAPBondMgr_GetParameter?relay
        PUBLIC ??GAPBondMgr_Init?relay
        PUBLIC ??GAPBondMgr_LinkEst?relay
        PUBLIC ??GAPBondMgr_PasscodeRsp?relay
        PUBLIC ??GAPBondMgr_ProcessEvent?relay
        PUBLIC ??GAPBondMgr_ProcessGAPMsg?relay
        PUBLIC ??GAPBondMgr_Register?relay
        PUBLIC ??GAPBondMgr_ResolveAddr?relay
        PUBLIC ??GAPBondMgr_ServiceChangeInd?relay
        PUBLIC ??GAPBondMgr_SetParameter?relay
        PUBLIC ??GAPBondMgr_UpdateCharCfg?relay
        PUBLIC GAPBondMgr_CheckNVLen
        PUBLIC GAPBondMgr_GetParameter
        PUBLIC GAPBondMgr_Init
        PUBLIC GAPBondMgr_LinkEst
        PUBLIC GAPBondMgr_PasscodeRsp
        PUBLIC GAPBondMgr_ProcessEvent
        PUBLIC GAPBondMgr_ProcessGAPMsg
        PUBLIC GAPBondMgr_Register
        PUBLIC GAPBondMgr_ResolveAddr
        PUBLIC GAPBondMgr_ServiceChangeInd
        PUBLIC GAPBondMgr_SetParameter
        PUBLIC GAPBondMgr_UpdateCharCfg
        PUBWEAK __Constant_f4240

GAP_Authenticate    SYMBOL "GAP_Authenticate"
??GAP_Authenticate?relay SYMBOL "?relay", GAP_Authenticate
GAP_Bond            SYMBOL "GAP_Bond"
??GAP_Bond?relay    SYMBOL "?relay", GAP_Bond
GAP_GetParamValue   SYMBOL "GAP_GetParamValue"
??GAP_GetParamValue?relay SYMBOL "?relay", GAP_GetParamValue
GAP_NumActiveConnections SYMBOL "GAP_NumActiveConnections"
??GAP_NumActiveConnections?relay SYMBOL "?relay", GAP_NumActiveConnections
GAP_PasscodeUpdate  SYMBOL "GAP_PasscodeUpdate"
??GAP_PasscodeUpdate?relay SYMBOL "?relay", GAP_PasscodeUpdate
GAP_ResolvePrivateAddr SYMBOL "GAP_ResolvePrivateAddr"
??GAP_ResolvePrivateAddr?relay SYMBOL "?relay", GAP_ResolvePrivateAddr
GAP_SendSlaveSecurityRequest SYMBOL "GAP_SendSlaveSecurityRequest"
??GAP_SendSlaveSecurityRequest?relay SYMBOL "?relay", GAP_SendSlaveSecurityRequest
GAP_SetParamValue   SYMBOL "GAP_SetParamValue"
??GAP_SetParamValue?relay SYMBOL "?relay", GAP_SetParamValue
GAP_Signable        SYMBOL "GAP_Signable"
??GAP_Signable?relay SYMBOL "?relay", GAP_Signable
GAP_TerminateAuth   SYMBOL "GAP_TerminateAuth"
??GAP_TerminateAuth?relay SYMBOL "?relay", GAP_TerminateAuth
GATTServApp_ReadAttr SYMBOL "GATTServApp_ReadAttr"
??GATTServApp_ReadAttr?relay SYMBOL "?relay", GATTServApp_ReadAttr
GATTServApp_RegisterForMsg SYMBOL "GATTServApp_RegisterForMsg"
??GATTServApp_RegisterForMsg?relay SYMBOL "?relay", GATTServApp_RegisterForMsg
GATTServApp_SendServiceChangedInd SYMBOL "GATTServApp_SendServiceChangedInd"
??GATTServApp_SendServiceChangedInd?relay SYMBOL "?relay", GATTServApp_SendServiceChangedInd
GATTServApp_UpdateCharCfg SYMBOL "GATTServApp_UpdateCharCfg"
??GATTServApp_UpdateCharCfg?relay SYMBOL "?relay", GATTServApp_UpdateCharCfg
GATT_FindHandleUUID SYMBOL "GATT_FindHandleUUID"
??GATT_FindHandleUUID?relay SYMBOL "?relay", GATT_FindHandleUUID
GATT_FindNextAttr   SYMBOL "GATT_FindNextAttr"
??GATT_FindNextAttr?relay SYMBOL "?relay", GATT_FindNextAttr
GGS_SetParameter    SYMBOL "GGS_SetParameter"
??GGS_SetParameter?relay SYMBOL "?relay", GGS_SetParameter
HCI_EXT_DeclareNvUsageCmd SYMBOL "HCI_EXT_DeclareNvUsageCmd"
??HCI_EXT_DeclareNvUsageCmd?relay SYMBOL "?relay", HCI_EXT_DeclareNvUsageCmd
HCI_LE_AddWhiteListCmd SYMBOL "HCI_LE_AddWhiteListCmd"
??HCI_LE_AddWhiteListCmd?relay SYMBOL "?relay", HCI_LE_AddWhiteListCmd
HCI_LE_ClearWhiteListCmd SYMBOL "HCI_LE_ClearWhiteListCmd"
??HCI_LE_ClearWhiteListCmd?relay SYMBOL "?relay", HCI_LE_ClearWhiteListCmd
linkDB_Find         SYMBOL "linkDB_Find"
??linkDB_Find?relay SYMBOL "?relay", linkDB_Find
linkDB_PerformFunc  SYMBOL "linkDB_PerformFunc"
??linkDB_PerformFunc?relay SYMBOL "?relay", linkDB_PerformFunc
osal_isbufset       SYMBOL "osal_isbufset"
??osal_isbufset?relay SYMBOL "?relay", osal_isbufset
osal_memcmp         SYMBOL "osal_memcmp"
??osal_memcmp?relay SYMBOL "?relay", osal_memcmp
osal_memcpy         SYMBOL "osal_memcpy"
??osal_memcpy?relay SYMBOL "?relay", osal_memcpy
osal_memset         SYMBOL "osal_memset"
??osal_memset?relay SYMBOL "?relay", osal_memset
osal_msg_deallocate SYMBOL "osal_msg_deallocate"
??osal_msg_deallocate?relay SYMBOL "?relay", osal_msg_deallocate
osal_msg_receive    SYMBOL "osal_msg_receive"
??osal_msg_receive?relay SYMBOL "?relay", osal_msg_receive
osal_snv_read       SYMBOL "osal_snv_read"
??osal_snv_read?relay SYMBOL "?relay", osal_snv_read
osal_snv_write      SYMBOL "osal_snv_write"
??osal_snv_write?relay SYMBOL "?relay", osal_snv_write
GAPBondMgr_CheckNVLen SYMBOL "GAPBondMgr_CheckNVLen"
??GAPBondMgr_CheckNVLen?relay SYMBOL "?relay", GAPBondMgr_CheckNVLen
GAPBondMgr_GetParameter SYMBOL "GAPBondMgr_GetParameter"
??GAPBondMgr_GetParameter?relay SYMBOL "?relay", GAPBondMgr_GetParameter
GAPBondMgr_Init     SYMBOL "GAPBondMgr_Init"
??GAPBondMgr_Init?relay SYMBOL "?relay", GAPBondMgr_Init
GAPBondMgr_LinkEst  SYMBOL "GAPBondMgr_LinkEst"
??GAPBondMgr_LinkEst?relay SYMBOL "?relay", GAPBondMgr_LinkEst
GAPBondMgr_PasscodeRsp SYMBOL "GAPBondMgr_PasscodeRsp"
??GAPBondMgr_PasscodeRsp?relay SYMBOL "?relay", GAPBondMgr_PasscodeRsp
GAPBondMgr_ProcessEvent SYMBOL "GAPBondMgr_ProcessEvent"
??GAPBondMgr_ProcessEvent?relay SYMBOL "?relay", GAPBondMgr_ProcessEvent
GAPBondMgr_ProcessGAPMsg SYMBOL "GAPBondMgr_ProcessGAPMsg"
??GAPBondMgr_ProcessGAPMsg?relay SYMBOL "?relay", GAPBondMgr_ProcessGAPMsg
GAPBondMgr_Register SYMBOL "GAPBondMgr_Register"
??GAPBondMgr_Register?relay SYMBOL "?relay", GAPBondMgr_Register
GAPBondMgr_ResolveAddr SYMBOL "GAPBondMgr_ResolveAddr"
??GAPBondMgr_ResolveAddr?relay SYMBOL "?relay", GAPBondMgr_ResolveAddr
GAPBondMgr_ServiceChangeInd SYMBOL "GAPBondMgr_ServiceChangeInd"
??GAPBondMgr_ServiceChangeInd?relay SYMBOL "?relay", GAPBondMgr_ServiceChangeInd
GAPBondMgr_SetParameter SYMBOL "GAPBondMgr_SetParameter"
??GAPBondMgr_SetParameter?relay SYMBOL "?relay", GAPBondMgr_SetParameter
GAPBondMgr_UpdateCharCfg SYMBOL "GAPBondMgr_UpdateCharCfg"
??GAPBondMgr_UpdateCharCfg?relay SYMBOL "?relay", GAPBondMgr_UpdateCharCfg

        EXTERN ??GAP_Authenticate?relay
        EXTERN ??GAP_Bond?relay
        EXTERN ??GAP_GetParamValue?relay
        EXTERN ??GAP_NumActiveConnections?relay
        EXTERN ??GAP_PasscodeUpdate?relay
        EXTERN ??GAP_ResolvePrivateAddr?relay
        EXTERN ??GAP_SendSlaveSecurityRequest?relay
        EXTERN ??GAP_SetParamValue?relay
        EXTERN ??GAP_Signable?relay
        EXTERN ??GAP_TerminateAuth?relay
        EXTERN ??GATTServApp_ReadAttr?relay
        EXTERN ??GATTServApp_RegisterForMsg?relay
        EXTERN ??GATTServApp_SendServiceChangedInd?relay
        EXTERN ??GATTServApp_UpdateCharCfg?relay
        EXTERN ??GATT_FindHandleUUID?relay
        EXTERN ??GATT_FindNextAttr?relay
        EXTERN ??GGS_SetParameter?relay
        EXTERN ??HCI_EXT_DeclareNvUsageCmd?relay
        EXTERN ??HCI_LE_AddWhiteListCmd?relay
        EXTERN ??HCI_LE_ClearWhiteListCmd?relay
        EXTERN ??linkDB_Find?relay
        EXTERN ??linkDB_PerformFunc?relay
        EXTERN ??osal_isbufset?relay
        EXTERN ??osal_memcmp?relay
        EXTERN ??osal_memcpy?relay
        EXTERN ??osal_memset?relay
        EXTERN ??osal_msg_deallocate?relay
        EXTERN ??osal_msg_receive?relay
        EXTERN ??osal_snv_read?relay
        EXTERN ??osal_snv_write?relay
        EXTERN GAP_Authenticate
        EXTERN GAP_Bond
        EXTERN GAP_GetParamValue
        EXTERN GAP_NumActiveConnections
        EXTERN GAP_PasscodeUpdate
        EXTERN GAP_ResolvePrivateAddr
        EXTERN GAP_SendSlaveSecurityRequest
        EXTERN GAP_SetParamValue
        EXTERN GAP_Signable
        EXTERN GAP_TerminateAuth
        EXTERN GATTServApp_ReadAttr
        EXTERN GATTServApp_RegisterForMsg
        EXTERN GATTServApp_SendServiceChangedInd
        EXTERN GATTServApp_UpdateCharCfg
        EXTERN GATT_FindHandleUUID
        EXTERN GATT_FindNextAttr
        EXTERN GGS_SetParameter
        EXTERN HCI_EXT_DeclareNvUsageCmd
        EXTERN HCI_LE_AddWhiteListCmd
        EXTERN HCI_LE_ClearWhiteListCmd
        EXTERN clientCharCfgUUID
        EXTERN linkDB_Find
        EXTERN linkDB_PerformFunc
        EXTERN osal_isbufset
        EXTERN osal_memcmp
        EXTERN osal_memcpy
        EXTERN osal_memset
        EXTERN osal_msg_deallocate
        EXTERN osal_msg_receive
        EXTERN osal_snv_read
        EXTERN osal_snv_write

// D:\NTHU\¬ã¨s\Important\ThesisCode\Code\GitLabCloud\NewEcoExec\codegenerator\Device\EcoBT\Project\ble\Profiles\Roles\gapbondmgr.c
//    1 /**************************************************************************************************
//    2   Filename:       gapbondmgr.c
//    3   Revised:        $Date: 2011-02-24 15:46:53 -0800 (Thu, 24 Feb 2011) $
//    4   Revision:       $Revision: 10 $
//    5 
//    6   Description:    GAP peripheral profile manages bonded connections
//    7 
//    8 
//    9   Copyright 2011-2012 Texas Instruments Incorporated. All rights reserved.
//   10 
//   11   IMPORTANT: Your use of this Software is limited to those specific rights
//   12   granted under the terms of a software license agreement between the user
//   13   who downloaded the software, his/her employer (which must be your employer)
//   14   and Texas Instruments Incorporated (the "License").  You may not use this
//   15   Software unless you agree to abide by the terms of the License. The License
//   16   limits your use, and you acknowledge, that the Software may not be modified,
//   17   copied or distributed unless embedded on a Texas Instruments microcontroller
//   18   or used solely and exclusively in conjunction with a Texas Instruments radio
//   19   frequency transceiver, which is integrated into your product.  Other than for
//   20   the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   21   works of, modify, distribute, perform, display or sell this Software and/or
//   22   its documentation for any purpose.
//   23 
//   24   YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   25   PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   26   INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   27   NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   28   TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   29   NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   30   LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   31   INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   32   OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   33   OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   34   (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   35 
//   36   Should you have any questions regarding your right to use this Software,
//   37   contact Texas Instruments Incorporated at www.TI.com.
//   38 **************************************************************************************************/
//   39 
//   40 #if ( HOST_CONFIG & ( CENTRAL_CFG | PERIPHERAL_CFG ) )
//   41 
//   42 /*********************************************************************
//   43  * INCLUDES
//   44  */
//   45 #include "bcomdef.h"
//   46 #include "OSAL.h"
//   47 #include "osal_snv.h"
//   48 #include "gap.h"
//   49 #include "linkdb.h"
//   50 #include "gatt.h"
//   51 #include "gatt_uuid.h"
//   52 #include "hci.h"
//   53 #include "gattservapp.h"
//   54 #include "gapgattserver.h"
//   55 #include "gapbondmgr.h"
//   56 
//   57 /*********************************************************************
//   58  * MACROS
//   59  */
//   60 
//   61 /*********************************************************************
//   62  * CONSTANTS
//   63  */
//   64 // Profile Events
//   65 
//   66 // Bonded State Flags
//   67 #define GAP_BONDED_STATE_AUTHENTICATED                  0x0001
//   68 #define GAP_BONDED_STATE_SERVICE_CHANGED                0x0002
//   69 
//   70 /**
//   71  * GAP Bond Manager NV layout
//   72  *
//   73  * The NV definitions:
//   74  *     BLE_NVID_GAP_BOND_START - starting NV ID
//   75  *     GAP_BONDINGS_MAX - Maximum number of bonding allowed (10 is max for number of NV IDs allocated in bcomdef.h).
//   76  *
//   77  * A single bonding entry consists of 6 components (NV items):
//   78  *     Bond Record - defined as gapBondRec_t and uses GAP_BOND_REC_ID_OFFSET for an NV ID
//   79  *     local LTK Info - defined as gapBondLTK_t and uses GAP_BOND_LOCAL_LTK_OFFSET for an NV ID
//   80  *     device LTK Info - defined as gapBondLTK_t and uses GAP_BOND_DEV_LTK_OFFSET for an NV ID
//   81  *     device IRK - defined as "uint8 devIRK[KEYLEN]" and uses GAP_BOND_DEV_IRK_OFFSET for an NV ID
//   82  *     device CSRK - defined as "uint8 devCSRK[KEYLEN]" and uses GAP_BOND_DEV_CSRK_OFFSET for an NV ID
//   83  *     device Sign Counter - defined as a uint32 and uses GAP_BOND_DEV_SIGN_COUNTER_OFFSET for an NV ID
//   84  *
//   85  * When the device is initialized for the first time, all (GAP_BONDINGS_MAX) NV items are created and
//   86  * initialized to all 0xFF's. A bonding record of all 0xFF's indicates that the bonding record is empty
//   87  * and free to use.
//   88  *
//   89  * The calculation for each bonding records NV IDs:
//   90  *    mainRecordNvID = ((bondIdx * GAP_BOND_REC_IDS) + BLE_NVID_GAP_BOND_START)
//   91  *    localLTKNvID = (((bondIdx * GAP_BOND_REC_IDS) + GAP_BOND_LOCAL_LTK_OFFSET) + BLE_NVID_GAP_BOND_START)
//   92  *
//   93  */
//   94 #define GAP_BOND_REC_ID_OFFSET              0 //!< NV ID for the main bonding record
//   95 #define GAP_BOND_LOCAL_LTK_OFFSET           1 //!< NV ID for the bonding record's local LTK information
//   96 #define GAP_BOND_DEV_LTK_OFFSET             2 //!< NV ID for the bonding records' device LTK information
//   97 #define GAP_BOND_DEV_IRK_OFFSET             3 //!< NV ID for the bonding records' device IRK
//   98 #define GAP_BOND_DEV_CSRK_OFFSET            4 //!< NV ID for the bonding records' device CSRK
//   99 #define GAP_BOND_DEV_SIGN_COUNTER_OFFSET    5 //!< NV ID for the bonding records' device Sign Counter
//  100 
//  101 #define GAP_BOND_REC_IDS                    6
//  102 
//  103 // Macros to calculate the index/offset in to NV space
//  104 #define calcNvID(Idx, offset)               (((((Idx) * GAP_BOND_REC_IDS) + (offset))) + BLE_NVID_GAP_BOND_START)
//  105 #define mainRecordNvID(bondIdx)             (calcNvID((bondIdx), GAP_BOND_REC_ID_OFFSET))
//  106 #define localLTKNvID(bondIdx)               (calcNvID((bondIdx), GAP_BOND_LOCAL_LTK_OFFSET))
//  107 #define devLTKNvID(bondIdx)                 (calcNvID((bondIdx), GAP_BOND_DEV_LTK_OFFSET))
//  108 #define devIRKNvID(bondIdx)                 (calcNvID((bondIdx), GAP_BOND_DEV_IRK_OFFSET))
//  109 #define devCSRKNvID(bondIdx)                (calcNvID((bondIdx), GAP_BOND_DEV_CSRK_OFFSET))
//  110 #define devSignCounterNvID(bondIdx)         (calcNvID((bondIdx), GAP_BOND_DEV_SIGN_COUNTER_OFFSET))
//  111 
//  112 // Macros to calculate the GATT index/offset in to NV space
//  113 #define gattCfgNvID(Idx)                    ((Idx) + BLE_NVID_GATT_CFG_START)
//  114 
//  115 // Key Size Limits
//  116 #define MIN_ENC_KEYSIZE       7   //!< Minimum number of bytes for the encryption key
//  117 #define MAX_ENC_KEYSIZE       16  //!< Maximum number of bytes for the encryption key
//  118 
//  119 
//  120 /*********************************************************************
//  121  * TYPEDEFS
//  122  */
//  123 
//  124 // Structure of NV data for the connected device's encryption information
//  125 typedef struct
//  126 {
//  127   uint8   LTK[KEYLEN];              // Long Term Key (LTK)
//  128   uint16  div;  //lint -e754        // LTK eDiv
//  129   uint8   rand[B_RANDOM_NUM_SIZE];  // LTK random number
//  130   uint8   keySize;                  // LTK key size
//  131 } gapBondLTK_t;
//  132 
//  133 // Structure of NV data for the connected device's address information
//  134 typedef struct
//  135 {
//  136   uint8   publicAddr[B_ADDR_LEN];     // Master's address
//  137   uint8   reconnectAddr[B_ADDR_LEN];  // Privacy Reconnection Address
//  138   uint16  stateFlags;                 // State flags: SM_AUTH_STATE_AUTHENTICATED & SM_AUTH_STATE_BONDING
//  139 } gapBondRec_t;
//  140 
//  141 // Structure of NV data for the connected device's characteristic configuration
//  142 typedef struct
//  143 {
//  144   uint16 attrHandle;  // attribute handle
//  145   uint8  value;       // attribute value for this device
//  146 } gapBondCharCfg_t;
//  147 
//  148 /*********************************************************************
//  149  * GLOBAL VARIABLES
//  150  */
//  151 
//  152 /*********************************************************************
//  153  * EXTERNAL VARIABLES
//  154  */
//  155 
//  156 /*********************************************************************
//  157  * EXTERNAL FUNCTIONS
//  158  */
//  159 
//  160 /*********************************************************************
//  161  * LOCAL VARIABLES
//  162  */

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//  163 static uint8 gapBondMgr_TaskID;   // Task ID for internal task/event processing
gapBondMgr_TaskID:
        DS 1
        REQUIRE __INIT_XDATA_Z
//  164 
//  165 // GAPBonding Parameters

        RSEG XDATA_I:XDATA:NOROOT(0)
//  166 static uint8 gapBond_PairingMode = GAPBOND_PAIRING_MODE_WAIT_FOR_REQ;
gapBond_PairingMode:
        DATA8
        DS 1
        REQUIRE `?<Initializer for gapBond_PairingMode>`
        REQUIRE __INIT_XDATA_I

        RSEG XDATA_I:XDATA:NOROOT(0)
//  167 static uint16 gapBond_InitiateWait = 1000;  // Default to 1 second
gapBond_InitiateWait:
        DATA16
        DS 2
        REQUIRE `?<Initializer for gapBond_InitiateWait>`
        REQUIRE __INIT_XDATA_I

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//  168 static uint8 gapBond_MITM = FALSE;
gapBond_MITM:
        DS 1
        REQUIRE __INIT_XDATA_Z

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//  169 static uint8 gapBond_IOCap = GAPBOND_IO_CAP_DISPLAY_ONLY;
gapBond_IOCap:
        DS 1
        REQUIRE __INIT_XDATA_Z

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//  170 static uint8 gapBond_OOBDataFlag = FALSE;
gapBond_OOBDataFlag:
        DS 1
        REQUIRE __INIT_XDATA_Z

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//  171 static uint8 gapBond_OOBData[KEYLEN] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
gapBond_OOBData:
        DS 16
        REQUIRE __INIT_XDATA_Z

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//  172 static uint8 gapBond_Bonding = FALSE;
gapBond_Bonding:
        DS 1
        REQUIRE __INIT_XDATA_Z

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//  173 static uint8 gapBond_AutoFail = FALSE;
gapBond_AutoFail:
        DS 1
        REQUIRE __INIT_XDATA_Z

        RSEG XDATA_I:XDATA:NOROOT(0)
//  174 static uint8 gapBond_AutoFailReason = SMP_PAIRING_FAILED_NOT_SUPPORTED;
gapBond_AutoFailReason:
        DATA8
        DS 1
        REQUIRE `?<Initializer for gapBond_AutoFailReason>`
        REQUIRE __INIT_XDATA_I

        RSEG XDATA_I:XDATA:NOROOT(0)
//  175 static uint8 gapBond_KeyDistList =
gapBond_KeyDistList:
        DATA8
        DS 1
        REQUIRE `?<Initializer for gapBond_KeyDistList>`
        REQUIRE __INIT_XDATA_I
//  176 (
//  177   GAPBOND_KEYDIST_SENCKEY     // sEncKey enabled, to send the encryption key
//  178    | GAPBOND_KEYDIST_SIDKEY   // sIdKey enabled, to send the IRK, and BD_ADDR
//  179    | GAPBOND_KEYDIST_SSIGN    // sSign enabled, to send the CSRK
//  180    | GAPBOND_KEYDIST_MENCKEY  // mEncKey enabled, to get the master's encryption key
//  181    | GAPBOND_KEYDIST_MIDKEY   // mIdKey enabled, to get the master's IRK and BD_ADDR
//  182    | GAPBOND_KEYDIST_MSIGN    // mSign enabled, to get the master's CSRK
//  183 );

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA32
//  184 static uint32 gapBond_Passcode = 0;
gapBond_Passcode:
        DS 4
        REQUIRE __INIT_XDATA_Z

        RSEG XDATA_I:XDATA:NOROOT(0)
//  185 static uint8  gapBond_KeySize = MAX_ENC_KEYSIZE;
gapBond_KeySize:
        DATA8
        DS 1
        REQUIRE `?<Initializer for gapBond_KeySize>`
        REQUIRE __INIT_XDATA_I
//  186 

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA16
//  187 static const gapBondCBs_t *pGapBondCB = NULL;
pGapBondCB:
        DS 2
        REQUIRE __INIT_XDATA_Z
//  188 
//  189 // Local RAM shadowed bond records

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//  190 static gapBondRec_t bonds[GAP_BONDINGS_MAX] = {0};
bonds:
        DS 140
        REQUIRE __INIT_XDATA_Z
//  191 

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//  192 static uint8 autoSyncWhiteList = FALSE;
autoSyncWhiteList:
        DS 1
        REQUIRE __INIT_XDATA_Z
//  193 
//  194 /*********************************************************************
//  195  * LOCAL FUNCTIONS
//  196  */
//  197 static uint8 gapBondMgrChangeState( uint8 idx, uint16 state, uint8 set );
//  198 static uint8 gapBondMgrUpdateCharCfg( uint8 idx, uint16 attrHandle, uint16 value );
//  199 static gapBondCharCfg_t *gapBondMgrFindCharCfgItem( uint16 attrHandle,
//  200                                                     gapBondCharCfg_t *charCfgTbl );
//  201 static void gapBondMgrInvertCharCfgItem( gapBondCharCfg_t *charCfgTbl );
//  202 static uint8 gapBondMgrAddBond( gapBondRec_t *pBondRec,
//  203                                 gapBondLTK_t *pLocalLTK, gapBondLTK_t *pDevLTK,
//  204                                 uint8 *pIRK, uint8 *pSRK, uint32 signCounter );
//  205 static uint8 gapBondMgrGetStateFlags( uint8 idx );
//  206 static bStatus_t gapBondMgrGetPublicAddr( uint8 idx, uint8 *pAddr );
//  207 static uint8 gapBondMgrFindReconnectAddr( uint8 *pReconnectAddr );
//  208 static uint8 gapBondMgrFindAddr( uint8 *pDevAddr );
//  209 static uint8 gapBondMgrResolvePrivateAddr( uint8 *pAddr );
//  210 static void gapBondMgrReadBonds( void );
//  211 static uint8 gapBondMgrFindEmpty( void );
//  212 static uint8 gapBondMgrBondTotal( void );
//  213 static bStatus_t gapBondMgrEraseAllBondings( void );
//  214 static bStatus_t gapBondMgrEraseBonding( uint8 idx );
//  215 static void gapBondMgr_ProcessOSALMsg( osal_event_hdr_t *pMsg );
//  216 static void gapBondMgrSendServiceChange( linkDBItem_t *pLinkItem );
//  217 static void gapBondMgr_ProcessGATTMsg( gattMsgEvent_t *pMsg );
//  218 static void gapBondMgr_ProcessGATTServMsg( gattEventHdr_t *pMsg );
//  219 static void gapBondSetupPrivFlag( void );
//  220 static void gapBondMgrBondReq( uint16 connHandle, uint8 idx, uint8 stateFlags,
//  221                                uint8 role, uint8 startEncryption );
//  222 static void gapBondMgrAuthenticate( uint16 connHandle, uint8 addrType,
//  223                                     gapPairingReq_t *pPairReq );
//  224 static void gapBondMgr_SyncWhiteList( void );
//  225 static void gapBondMgr_SyncCharCfg( uint16 connHandle );
//  226 
//  227 #if ( HOST_CONFIG & PERIPHERAL_CFG )
//  228 static void gapBondMgrSlaveSecurityReq( uint16 connHandle );
//  229 #endif
//  230 
//  231 /*********************************************************************
//  232  * NETWORK LAYER CALLBACKS
//  233  */
//  234 
//  235 /*********************************************************************
//  236  * PUBLIC FUNCTIONS
//  237  */
//  238 
//  239 /*********************************************************************
//  240  * @brief   Set a GAP Bond Manager parameter.
//  241  *
//  242  * Public function defined in gapbondmgr.h.
//  243  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  244 bStatus_t GAPBondMgr_SetParameter( uint16 param, uint8 len, void *pValue )
GAPBondMgr_SetParameter:
        CODE
//  245 {
        MOV     A,#-0xc
        LCALL   ?BANKED_ENTER_XDATA
        ; Saved register size: 12
        ; Auto size: 0
        MOV     A,R1
        MOV     R7,A
//  246   bStatus_t ret = SUCCESS;  // return value
        MOV     R6,#0x0
//  247 
//  248   switch ( param )
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     R0,#?V0 + 0
        LCALL   ?US_SWITCH_DENSE
`?<Jumptable for GAPBondMgr_SetParameter>_0`:
        DATA
        DATA16
        DATA
        DATA16
        DW        1024
        DATA
        DATA8
        DATA
        DATA8
        DB        13
        DATA
        DATA16
        DATA
        DATA16
        DW        ??GAPBondMgr_SetParameter_0
        DATA
        DATA16
        DATA
        DATA16
        DW        ??GAPBondMgr_SetParameter_1
        DATA
        DATA16
        DATA
        DATA16
        DW        ??GAPBondMgr_SetParameter_2
        DATA
        DATA16
        DATA
        DATA16
        DW        ??GAPBondMgr_SetParameter_3
        DATA
        DATA16
        DATA
        DATA16
        DW        ??GAPBondMgr_SetParameter_4
        DATA
        DATA16
        DATA
        DATA16
        DW        ??GAPBondMgr_SetParameter_5
        DATA
        DATA16
        DATA
        DATA16
        DW        ??GAPBondMgr_SetParameter_6
        DATA
        DATA16
        DATA
        DATA16
        DW        ??GAPBondMgr_SetParameter_7
        DATA
        DATA16
        DATA
        DATA16
        DW        ??GAPBondMgr_SetParameter_8
        DATA
        DATA16
        DATA
        DATA16
        DW        ??GAPBondMgr_SetParameter_9
        DATA
        DATA16
        DATA
        DATA16
        DW        ??GAPBondMgr_SetParameter_10
        DATA
        DATA16
        DATA
        DATA16
        DW        ??GAPBondMgr_SetParameter_11
        DATA
        DATA16
        DATA
        DATA16
        DW        ??GAPBondMgr_SetParameter_12
        DATA
        DATA16
        DATA
        DATA16
        DW        ??GAPBondMgr_SetParameter_13
        DATA
        DATA16
        DATA
        DATA16
        DW        ??GAPBondMgr_SetParameter_14
        CODE
//  249   {
//  250     case GAPBOND_PAIRING_MODE:
//  251       if ( (len == sizeof ( uint8 )) && (*((uint8*)pValue) <= GAPBOND_PAIRING_MODE_INITIATE) )
??GAPBondMgr_SetParameter_1:
        MOV     A,#0x1
        XRL     A,R7
        JZ      $+5
        LJMP    ??GAPBondMgr_SetParameter_15 & 0xFFFF
        MOV     DPL,R4
        MOV     DPH,R5
        MOVX    A,@DPTR
        MOV     R0,A
        CLR     C
        SUBB    A,#0x3
        JC      $+5
        LJMP    ??GAPBondMgr_SetParameter_15 & 0xFFFF
//  252       {
//  253         gapBond_PairingMode = *((uint8*)pValue);
        MOV     A,R0
        MOV     DPTR,#gapBond_PairingMode
        LJMP    ??GAPBondMgr_SetParameter_16 & 0xFFFF
//  254       }
//  255       else
//  256       {
//  257         ret = bleInvalidRange;
//  258       }
//  259       break;
//  260 
//  261     case GAPBOND_INITIATE_WAIT:
//  262       if ( len == sizeof ( uint16 ) )
??GAPBondMgr_SetParameter_2:
        MOV     A,#0x2
        XRL     A,R7
        JZ      $+5
        LJMP    ??GAPBondMgr_SetParameter_15 & 0xFFFF
//  263       {
//  264         gapBond_InitiateWait = *((uint16*)pValue);
        MOV     DPL,R4
        MOV     DPH,R5
        LCALL   ?Subroutine11 & 0xFFFF
//  265       }
??CrossCallReturnLabel_10:
        MOV     DPTR,#gapBond_InitiateWait
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        LJMP    ??GAPBondMgr_SetParameter_16 & 0xFFFF
//  266       else
//  267       {
//  268         ret = bleInvalidRange;
//  269       }
//  270       break;
//  271 
//  272     case GAPBOND_MITM_PROTECTION:
//  273       if ( (len == sizeof ( uint8 )) && (*((uint8*)pValue) <= TRUE) )
??GAPBondMgr_SetParameter_3:
        MOV     A,#0x1
        XRL     A,R7
        JZ      $+5
        LJMP    ??GAPBondMgr_SetParameter_15 & 0xFFFF
        LCALL   ?Subroutine13 & 0xFFFF
??CrossCallReturnLabel_15:
        JC      $+5
        LJMP    ??GAPBondMgr_SetParameter_15 & 0xFFFF
//  274       {
//  275         gapBond_MITM = *((uint8*)pValue);
        MOV     A,R0
        MOV     DPTR,#gapBond_MITM
        LJMP    ??GAPBondMgr_SetParameter_16 & 0xFFFF
//  276       }
//  277       else
//  278       {
//  279         ret = bleInvalidRange;
//  280       }
//  281       break;
//  282 
//  283     case GAPBOND_IO_CAPABILITIES:
//  284       if ( (len == sizeof ( uint8 )) && (*((uint8*)pValue) <= GAPBOND_IO_CAP_KEYBOARD_DISPLAY) )
??GAPBondMgr_SetParameter_4:
        MOV     A,#0x1
        XRL     A,R7
        JZ      $+5
        LJMP    ??GAPBondMgr_SetParameter_15 & 0xFFFF
        MOV     DPL,R4
        MOV     DPH,R5
        MOVX    A,@DPTR
        MOV     R0,A
        CLR     C
        SUBB    A,#0x5
        JC      $+5
        LJMP    ??GAPBondMgr_SetParameter_15 & 0xFFFF
//  285       {
//  286         gapBond_IOCap = *((uint8*)pValue);
        MOV     A,R0
        MOV     DPTR,#gapBond_IOCap
        LJMP    ??GAPBondMgr_SetParameter_16 & 0xFFFF
//  287       }
//  288       else
//  289       {
//  290         ret = bleInvalidRange;
//  291       }
//  292       break;
//  293 
//  294     case GAPBOND_OOB_ENABLED:
//  295       if ( (len == sizeof ( uint8 )) && (*((uint8*)pValue) <= TRUE) )
??GAPBondMgr_SetParameter_5:
        MOV     A,#0x1
        XRL     A,R7
        JZ      $+5
        LJMP    ??GAPBondMgr_SetParameter_15 & 0xFFFF
        LCALL   ?Subroutine13 & 0xFFFF
??CrossCallReturnLabel_16:
        JC      $+5
        LJMP    ??GAPBondMgr_SetParameter_15 & 0xFFFF
//  296       {
//  297         gapBond_OOBDataFlag = *((uint8*)pValue);
        MOV     A,R0
        MOV     DPTR,#gapBond_OOBDataFlag
        LJMP    ??GAPBondMgr_SetParameter_16 & 0xFFFF
//  298       }
//  299       else
//  300       {
//  301         ret = bleInvalidRange;
//  302       }
//  303       break;
//  304 
//  305     case GAPBOND_OOB_DATA:
//  306       if ( len == KEYLEN )
??GAPBondMgr_SetParameter_6:
        MOV     A,#0x10
        XRL     A,R7
        JZ      $+5
        LJMP    ??GAPBondMgr_SetParameter_15 & 0xFFFF
//  307       {
//  308         VOID osal_memcpy( gapBond_OOBData, pValue, KEYLEN ) ;
        ; Setup parameters for call to function osal_memcpy
        MOV     ?V0 + 0,#0x10
        MOV     ?V0 + 1,R6
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     R2,#gapBond_OOBData & 0xff
        MOV     R3,#(gapBond_OOBData >> 8) & 0xff
        LCALL   ??osal_memcpy?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        LJMP    ??GAPBondMgr_SetParameter_17 & 0xFFFF
//  309       }
//  310       else
//  311       {
//  312         ret = bleInvalidRange;
//  313       }
//  314       break;
//  315 
//  316     case GAPBOND_BONDING_ENABLED:
//  317       if ( (len == sizeof ( uint8 )) && (*((uint8*)pValue) <= TRUE) )
??GAPBondMgr_SetParameter_7:
        MOV     A,#0x1
        XRL     A,R7
        JZ      $+5
        LJMP    ??GAPBondMgr_SetParameter_15 & 0xFFFF
        LCALL   ?Subroutine13 & 0xFFFF
??CrossCallReturnLabel_17:
        JC      $+5
        LJMP    ??GAPBondMgr_SetParameter_15 & 0xFFFF
//  318       {
//  319         gapBond_Bonding = *((uint8*)pValue);
        MOV     A,R0
        MOV     DPTR,#gapBond_Bonding
        SJMP    ??GAPBondMgr_SetParameter_16
//  320       }
//  321       else
//  322       {
//  323         ret = bleInvalidRange;
//  324       }
//  325       break;
//  326 
//  327     case GAPBOND_KEY_DIST_LIST:
//  328       if ( len == sizeof ( uint8 ) )
??GAPBondMgr_SetParameter_8:
        MOV     A,#0x1
        XRL     A,R7
        JZ      $+5
        LJMP    ??GAPBondMgr_SetParameter_15 & 0xFFFF
//  329       {
//  330         gapBond_KeyDistList = *((uint8*)pValue);
        MOV     DPL,R4
        MOV     DPH,R5
        MOVX    A,@DPTR
        MOV     DPTR,#gapBond_KeyDistList
        SJMP    ??GAPBondMgr_SetParameter_16
//  331       }
//  332       else
//  333       {
//  334         ret = bleInvalidRange;
//  335       }
//  336       break;
//  337 
//  338     case GAPBOND_DEFAULT_PASSCODE:
//  339       if ( (len == sizeof ( uint32 ))
//  340           && (*((uint32*)pValue) <= GAP_PASSCODE_MAX) )
??GAPBondMgr_SetParameter_9:
        MOV     A,#0x4
        XRL     A,R7
        JZ      $+5
        LJMP    ??GAPBondMgr_SetParameter_15 & 0xFFFF
        MOV     DPL,R4
        MOV     DPH,R5
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     DPTR,#__Constant_f4240
        MOV     R0,#?V0 + 0
        LCALL   ?UL_GE_X
        JC      ??GAPBondMgr_SetParameter_15
//  341       {
//  342         gapBond_Passcode = *((uint32*)pValue);
        MOV     DPTR,#gapBond_Passcode
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_TO_X
        LJMP    ??GAPBondMgr_SetParameter_17 & 0xFFFF
//  343       }
//  344       else
//  345       {
//  346         ret = bleInvalidRange;
//  347       }
//  348       break;
//  349 
//  350     case GAPBOND_ERASE_ALLBONDS:
//  351       if ( len == 0 )
??GAPBondMgr_SetParameter_10:
        MOV     A,R7
        JNZ     ??GAPBondMgr_SetParameter_15
//  352       {
//  353         VOID gapBondMgrEraseAllBondings();
        ; Setup parameters for call to function gapBondMgrEraseAllBondings
        LCALL   ??gapBondMgrEraseAllBondings?relay
//  354         gapBondMgrReadBonds();
        ; Setup parameters for call to function gapBondMgrReadBonds
        SJMP    ??GAPBondMgr_SetParameter_18
//  355       }
//  356       else
//  357       {
//  358         ret = bleInvalidRange;
//  359       }
//  360       break;
//  361 
//  362     case GAPBOND_AUTO_FAIL_PAIRING:
//  363       if ( (len == sizeof ( uint8 )) && (*((uint8*)pValue) <= TRUE) )
??GAPBondMgr_SetParameter_11:
        MOV     A,#0x1
        XRL     A,R7
        JNZ     ??GAPBondMgr_SetParameter_15
        LCALL   ?Subroutine13 & 0xFFFF
??CrossCallReturnLabel_18:
        JNC     ??GAPBondMgr_SetParameter_15
//  364       {
//  365         gapBond_AutoFail = *((uint8*)pValue);
        MOV     A,R0
        MOV     DPTR,#gapBond_AutoFail
        SJMP    ??GAPBondMgr_SetParameter_16
//  366       }
//  367       else
//  368       {
//  369         ret = bleInvalidRange;
//  370       }
//  371       break;
//  372 
//  373     case GAPBOND_AUTO_FAIL_REASON:
//  374       if ( (len == sizeof ( uint8 )) && (*((uint8*)pValue) <= SMP_PAIRING_FAILED_REPEATED_ATTEMPTS) )
??GAPBondMgr_SetParameter_12:
        MOV     A,#0x1
        XRL     A,R7
        JNZ     ??GAPBondMgr_SetParameter_15
        MOV     DPL,R4
        MOV     DPH,R5
        MOVX    A,@DPTR
        MOV     R0,A
        CLR     C
        SUBB    A,#0xa
        JNC     ??GAPBondMgr_SetParameter_15
//  375       {
//  376         gapBond_AutoFailReason = *((uint8*)pValue);
        MOV     A,R0
        MOV     DPTR,#gapBond_AutoFailReason
        SJMP    ??GAPBondMgr_SetParameter_16
//  377       }
//  378       else
//  379       {
//  380         ret = bleInvalidRange;
//  381       }
//  382       break;
//  383 
//  384     case GAPBOND_KEYSIZE:
//  385       if ( (len == sizeof ( uint8 ))
//  386           && ((*((uint8*)pValue) >= MIN_ENC_KEYSIZE) && (*((uint8*)pValue) <= MAX_ENC_KEYSIZE)) )
??GAPBondMgr_SetParameter_13:
        MOV     A,#0x1
        XRL     A,R7
        JNZ     ??GAPBondMgr_SetParameter_15
        MOV     DPL,R4
        MOV     DPH,R5
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     A,#-0x7
        ADD     A,R0
        CLR     C
        SUBB    A,#0xa
        JNC     ??GAPBondMgr_SetParameter_15
//  387       {
//  388         gapBond_KeySize = *((uint8*)pValue);
        MOV     A,R0
        MOV     DPTR,#gapBond_KeySize
??GAPBondMgr_SetParameter_16:
        MOVX    @DPTR,A
        SJMP    ??GAPBondMgr_SetParameter_17
//  389       }
//  390       else
//  391       {
//  392         ret = bleInvalidRange;
//  393       }
//  394       break;
//  395 
//  396     case GAPBOND_AUTO_SYNC_WL:
//  397       if ( len == sizeof( uint8 ) )
??GAPBondMgr_SetParameter_14:
        MOV     A,#0x1
        XRL     A,R7
        JNZ     ??GAPBondMgr_SetParameter_15
//  398       {
//  399         uint8 oldVal = autoSyncWhiteList;
        MOV     DPTR,#autoSyncWhiteList
        MOVX    A,@DPTR
        MOV     R0,A
//  400 
//  401         autoSyncWhiteList = *((uint8 *)pValue);
        MOV     DPL,R4
        MOV     DPH,R5
        MOVX    A,@DPTR
        MOV     DPTR,#autoSyncWhiteList
        MOVX    @DPTR,A
//  402 
//  403         // only call if parameter changes from FALSE to TRUE
//  404         if ( ( oldVal == FALSE ) && ( autoSyncWhiteList == TRUE ) )
        MOV     A,R0
        JNZ     ??GAPBondMgr_SetParameter_17
        MOVX    A,@DPTR
        XRL     A,#0x1
        JNZ     ??GAPBondMgr_SetParameter_17
//  405         {
//  406           // make sure bond is updated from NV
//  407           gapBondMgrReadBonds();
        ; Setup parameters for call to function gapBondMgrReadBonds
??GAPBondMgr_SetParameter_18:
        LCALL   ??gapBondMgrReadBonds?relay
        SJMP    ??GAPBondMgr_SetParameter_17
//  408         }
//  409       }
//  410       else
//  411       {
//  412         ret = bleInvalidRange;
??GAPBondMgr_SetParameter_15:
        MOV     R6,#0x18
        SJMP    ??GAPBondMgr_SetParameter_17
//  413       }
//  414       break;
//  415 
//  416     default:
//  417       // The param value isn't part of this profile, try the GAP.
//  418       if ( (param < TGAP_PARAMID_MAX) && (len == sizeof ( uint16 )) )
??GAPBondMgr_SetParameter_0:
        CLR     C
        MOV     A,R2
        SUBB    A,#0x24
        MOV     A,R3
        SUBB    A,#0x0
        JNC     ??GAPBondMgr_SetParameter_19
        MOV     A,#0x2
        XRL     A,R7
        JNZ     ??GAPBondMgr_SetParameter_19
//  419       {
//  420         ret = GAP_SetParamValue( param, *((uint16*)pValue) );
        ; Setup parameters for call to function GAP_SetParamValue
        MOV     DPL,R4
        MOV     DPH,R5
        LCALL   ??Subroutine25_0 & 0xFFFF
//  421       }
??CrossCallReturnLabel_47:
        LCALL   ??GAP_SetParamValue?relay
        MOV     A,R1
        MOV     R6,A
        SJMP    ??GAPBondMgr_SetParameter_17
//  422       else
//  423       {
//  424         ret = INVALIDPARAMETER;
??GAPBondMgr_SetParameter_19:
        INC     R6
        INC     R6
//  425       }
//  426       break;
//  427   }
//  428 
//  429   return ( ret );
??GAPBondMgr_SetParameter_17:
        REQUIRE ?Subroutine6
        ; // Fall through to label ?Subroutine6
//  430 }

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine6:
        MOV     A,R6
        MOV     R1,A
        LJMP    ??Subroutine20_0 & 0xFFFF

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine13:
        MOV     DPL,R4
        MOV     DPH,R5
        MOVX    A,@DPTR
        MOV     R0,A
        CLR     C
        SUBB    A,#0x2
        RET
//  431 
//  432 /*********************************************************************
//  433  * @brief   Get a GAP Bond Manager parameter.
//  434  *
//  435  * Public function defined in gapbondmgr.h.
//  436  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  437 bStatus_t GAPBondMgr_GetParameter( uint16 param, void *pValue )
GAPBondMgr_GetParameter:
        CODE
//  438 {
        MOV     A,#-0xc
        LCALL   ?BANKED_ENTER_XDATA
        ; Saved register size: 12
        ; Auto size: 0
        MOV     ?V0 + 0,R4
        MOV     ?V0 + 1,R5
//  439   bStatus_t ret = SUCCESS;  // return value
        MOV     R6,#0x0
//  440 
//  441   switch ( param )
        MOV     ?V0 + 2,R2
        MOV     ?V0 + 3,R3
        MOV     R0,#?V0 + 2
        LCALL   ?US_SWITCH_DENSE
`?<Jumptable for GAPBondMgr_GetParameter>_0`:
        DATA
        DATA16
        DATA
        DATA16
        DW        1024
        DATA
        DATA8
        DATA
        DATA8
        DB        14
        DATA
        DATA16
        DATA
        DATA16
        DW        ??GAPBondMgr_GetParameter_0
        DATA
        DATA16
        DATA
        DATA16
        DW        ??GAPBondMgr_GetParameter_1
        DATA
        DATA16
        DATA
        DATA16
        DW        ??GAPBondMgr_GetParameter_2
        DATA
        DATA16
        DATA
        DATA16
        DW        ??GAPBondMgr_GetParameter_3
        DATA
        DATA16
        DATA
        DATA16
        DW        ??GAPBondMgr_GetParameter_4
        DATA
        DATA16
        DATA
        DATA16
        DW        ??GAPBondMgr_GetParameter_5
        DATA
        DATA16
        DATA
        DATA16
        DW        ??GAPBondMgr_GetParameter_6
        DATA
        DATA16
        DATA
        DATA16
        DW        ??GAPBondMgr_GetParameter_7
        DATA
        DATA16
        DATA
        DATA16
        DW        ??GAPBondMgr_GetParameter_8
        DATA
        DATA16
        DATA
        DATA16
        DW        ??GAPBondMgr_GetParameter_9
        DATA
        DATA16
        DATA
        DATA16
        DW        ??GAPBondMgr_GetParameter_0
        DATA
        DATA16
        DATA
        DATA16
        DW        ??GAPBondMgr_GetParameter_10
        DATA
        DATA16
        DATA
        DATA16
        DW        ??GAPBondMgr_GetParameter_11
        DATA
        DATA16
        DATA
        DATA16
        DW        ??GAPBondMgr_GetParameter_12
        DATA
        DATA16
        DATA
        DATA16
        DW        ??GAPBondMgr_GetParameter_13
        DATA
        DATA16
        DATA
        DATA16
        DW        ??GAPBondMgr_GetParameter_14
        CODE
//  442   {
//  443     case GAPBOND_PAIRING_MODE:
//  444       *((uint8*)pValue) = gapBond_PairingMode;
??GAPBondMgr_GetParameter_1:
        MOV     DPTR,#gapBond_PairingMode
        SJMP    ??GAPBondMgr_GetParameter_15
//  445       break;
//  446 
//  447     case GAPBOND_INITIATE_WAIT:
//  448       *((uint16*)pValue) = gapBond_InitiateWait;
??GAPBondMgr_GetParameter_2:
        MOV     DPTR,#gapBond_InitiateWait
        LCALL   ?Subroutine11 & 0xFFFF
??CrossCallReturnLabel_11:
        MOV     DPL,R4
        MOV     DPH,R5
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        LJMP    ??GAPBondMgr_GetParameter_16 & 0xFFFF
//  449       break;
//  450 
//  451     case GAPBOND_MITM_PROTECTION:
//  452       *((uint8*)pValue) = gapBond_MITM;
??GAPBondMgr_GetParameter_3:
        MOV     DPTR,#gapBond_MITM
        SJMP    ??GAPBondMgr_GetParameter_15
//  453       break;
//  454 
//  455     case GAPBOND_IO_CAPABILITIES:
//  456       *((uint8*)pValue) = gapBond_IOCap;
??GAPBondMgr_GetParameter_4:
        MOV     DPTR,#gapBond_IOCap
        SJMP    ??GAPBondMgr_GetParameter_15
//  457       break;
//  458 
//  459     case GAPBOND_OOB_ENABLED:
//  460       *((uint8*)pValue) = gapBond_OOBDataFlag;
??GAPBondMgr_GetParameter_5:
        MOV     DPTR,#gapBond_OOBDataFlag
        SJMP    ??GAPBondMgr_GetParameter_15
//  461       break;
//  462 
//  463     case GAPBOND_OOB_DATA:
//  464       VOID osal_memcpy( pValue, gapBond_OOBData, KEYLEN ) ;
??GAPBondMgr_GetParameter_6:
        ; Setup parameters for call to function osal_memcpy
        MOV     ?V0 + 2,#0x10
        MOV     ?V0 + 3,R6
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     R4,#gapBond_OOBData & 0xff
        MOV     R5,#(gapBond_OOBData >> 8) & 0xff
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
        LCALL   ??osal_memcpy?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
//  465       break;
        SJMP    ??GAPBondMgr_GetParameter_17
//  466 
//  467     case GAPBOND_BONDING_ENABLED:
//  468       *((uint8*)pValue) = gapBond_Bonding;
??GAPBondMgr_GetParameter_7:
        MOV     DPTR,#gapBond_Bonding
        SJMP    ??GAPBondMgr_GetParameter_15
//  469       break;
//  470 
//  471     case GAPBOND_KEY_DIST_LIST:
//  472       *((uint8*)pValue) = gapBond_KeyDistList;
??GAPBondMgr_GetParameter_8:
        MOV     DPTR,#gapBond_KeyDistList
        SJMP    ??GAPBondMgr_GetParameter_15
//  473       break;
//  474 
//  475     case GAPBOND_DEFAULT_PASSCODE:
//  476       *((uint32*)pValue) = gapBond_Passcode;
??GAPBondMgr_GetParameter_9:
        MOV     DPTR,#gapBond_Passcode
        LCALL   ?XLOAD_R2345
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        LCALL   ?XSTORE_R2345
//  477       break;
        SJMP    ??GAPBondMgr_GetParameter_17
//  478 
//  479     case GAPBOND_AUTO_FAIL_PAIRING:
//  480       *((uint8*)pValue) = gapBond_AutoFail;
??GAPBondMgr_GetParameter_10:
        MOV     DPTR,#gapBond_AutoFail
        SJMP    ??GAPBondMgr_GetParameter_15
//  481       break;
//  482 
//  483     case GAPBOND_AUTO_FAIL_REASON:
//  484       *((uint8*)pValue) = gapBond_AutoFailReason;
??GAPBondMgr_GetParameter_11:
        MOV     DPTR,#gapBond_AutoFailReason
        SJMP    ??GAPBondMgr_GetParameter_15
//  485       break;
//  486 
//  487     case GAPBOND_KEYSIZE:
//  488       *((uint8*)pValue) = gapBond_KeySize;
??GAPBondMgr_GetParameter_12:
        MOV     DPTR,#gapBond_KeySize
        SJMP    ??GAPBondMgr_GetParameter_15
//  489       break;
//  490 
//  491     case GAPBOND_AUTO_SYNC_WL:
//  492       *((uint8*)pValue) = autoSyncWhiteList;
??GAPBondMgr_GetParameter_13:
        MOV     DPTR,#autoSyncWhiteList
??GAPBondMgr_GetParameter_15:
        MOVX    A,@DPTR
        MOV     DPL,R4
        MOV     DPH,R5
        SJMP    ??GAPBondMgr_GetParameter_16
//  493       break;
//  494 
//  495     case GAPBOND_BOND_COUNT:
//  496       *((uint8*)pValue) = gapBondMgrBondTotal();
??GAPBondMgr_GetParameter_14:
        ; Setup parameters for call to function gapBondMgrBondTotal
        LCALL   ??gapBondMgrBondTotal?relay
        MOV     A,R1
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        SJMP    ??GAPBondMgr_GetParameter_16
//  497       break;
//  498 
//  499     default:
//  500       // The param value isn't part of this profile, try the GAP.
//  501       if ( param < TGAP_PARAMID_MAX )
??GAPBondMgr_GetParameter_0:
        CLR     C
        MOV     A,R2
        SUBB    A,#0x24
        MOV     A,R3
        SUBB    A,#0x0
        JNC     ??GAPBondMgr_GetParameter_18
//  502       {
//  503         *((uint16*)pValue) = GAP_GetParamValue( param );
        ; Setup parameters for call to function GAP_GetParamValue
        LCALL   ??GAP_GetParamValue?relay
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
??GAPBondMgr_GetParameter_16:
        MOVX    @DPTR,A
        SJMP    ??GAPBondMgr_GetParameter_17
//  504       }
//  505       else
//  506       {
//  507         ret = INVALIDPARAMETER;
??GAPBondMgr_GetParameter_18:
        INC     R6
        INC     R6
//  508       }
//  509       break;
//  510   }
//  511 
//  512   return ( ret );
??GAPBondMgr_GetParameter_17:
        LJMP    ?Subroutine6 & 0xFFFF
//  513 }

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine0:
        MOV     A,#0xe
        REQUIRE ??Subroutine19_0
        ; // Fall through to label ??Subroutine19_0

        RSEG BANKED_CODE:CODE:NOROOT(0)
??Subroutine19_0:
        LCALL   ?DEALLOC_XSTACK8
        REQUIRE ??Subroutine20_0
        ; // Fall through to label ??Subroutine20_0

        RSEG BANKED_CODE:CODE:NOROOT(0)
??Subroutine20_0:
        MOV     R7,#0x4
        LJMP    ?BANKED_LEAVE_XDATA
//  514 
//  515 /*********************************************************************
//  516  * @brief   Notify the Bond Manager that a connection has been made.
//  517  *
//  518  * Public function defined in gapbondmgr.h.
//  519  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  520 bStatus_t GAPBondMgr_LinkEst( uint8 addrType, uint8 *pDevAddr, uint16 connHandle, uint8 role )
GAPBondMgr_LinkEst:
        CODE
//  521 {
        MOV     A,#-0x10
        LCALL   ?BANKED_ENTER_XDATA
        ; Saved register size: 16
        ; Auto size: 52
        MOV     A,#-0x34
        LCALL   ?ALLOC_XSTACK8
        MOV     ?V0 + 2,R4
        MOV     ?V0 + 3,R5
//  522   uint8 idx;                          // NV Index
//  523   uint8 publicAddr[B_ADDR_LEN]        // Place to put the public address
//  524       = {0, 0, 0, 0, 0, 0};
        MOV     A,#0x20
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     DPH,#(`?<Constant {0, 0, 0, 0, 0, 0}>` >> 8) & 0xff
        MOV     DPL,#`?<Constant {0, 0, 0, 0, 0, 0}>` & 0xff
        MOV     A,#0x6
        LCALL   ?MOVE_LONG8_XDATA_XDATA
//  525 
//  526   idx = GAPBondMgr_ResolveAddr( addrType, pDevAddr, publicAddr );
        ; Setup parameters for call to function GAPBondMgr_ResolveAddr
        MOV     A,#0x20
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        LCALL   ??GAPBondMgr_ResolveAddr?relay
        MOV     A,R1
        MOV     ?V0 + 0,A
        MOV     A,#0x44
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R6,A
//  527   if ( idx < GAP_BONDINGS_MAX )
        MOV     A,R1
        CLR     C
        SUBB    A,#0xa
        JC      $+5
        LJMP    ??GAPBondMgr_LinkEst_0 & 0xFFFF
//  528   {
//  529     uint8 stateFlags = gapBondMgrGetStateFlags( idx );
        MOV     B,#0x6
        MOV     A,R1
        MUL     AB
        MOV     ?V0 + 1,A
        ; Setup parameters for call to function osal_snv_read
        MOV     A,#0x26
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,#0xe
        MOV     A,#0x20
        ADD     A,?V0 + 1
        MOV     R1,A
        LCALL   ??osal_snv_read?relay
        MOV     A,#0x32
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R7,A
//  530     smSigningInfo_t signingInfo;
//  531     gapBondCharCfg_t charCfg[GAP_CHAR_CFG_MAX]; // Space to read a char cfg record from NV
//  532 
//  533     // On peripheral, load the key information for the bonding
//  534     // On central and initiaiting security, load key to initiate encyption
//  535     gapBondMgrBondReq( connHandle, idx, stateFlags, role,
//  536                        ((gapBond_PairingMode == GAPBOND_PAIRING_MODE_INITIATE ) ? TRUE : FALSE) );
        MOV     DPTR,#gapBond_PairingMode
        MOVX    A,@DPTR
        XRL     A,#0x2
        JNZ     ??GAPBondMgr_LinkEst_1
        MOV     A,#0x1
        SJMP    ??GAPBondMgr_LinkEst_2
??GAPBondMgr_LinkEst_1:
        CLR     A
??GAPBondMgr_LinkEst_2:
        ; Setup parameters for call to function gapBondMgrBondReq
        MOV     ?V0 + 5,A
        MOV     R0,#?V0 + 5
        LCALL   ?PUSH_XSTACK_I_ONE
        MOV     A,R6
        MOV     R5,A
        MOV     A,R7
        MOV     R4,A
        MOV     R1,?V0 + 0
        MOV     R2,?V0 + 2
        MOV     R3,?V0 + 3
        LCALL   ??gapBondMgrBondReq?relay
        MOV     A,#0x1
        LCALL   ?DEALLOC_XSTACK8
//  537 
//  538     // Load the Signing Key
//  539     VOID osal_memset( &signingInfo, 0, sizeof ( smSigningInfo_t ) );
        ; Setup parameters for call to function osal_memset
        MOV     R4,#0x14
        MOV     R5,#0x0
        MOV     R1,#0x0
        MOV     A,#0xc
        LCALL   ?XSTACK_DISP0_8
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??osal_memset?relay
//  540     if ( osal_snv_read( devCSRKNvID(idx), KEYLEN, signingInfo.srk ) == SUCCESS )
        ; Setup parameters for call to function osal_snv_read
        MOV     A,#0xc
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,#0x10
        MOV     A,#0x24
        ADD     A,?V0 + 1
        MOV     R1,A
        LCALL   ??osal_snv_read?relay
        MOV     A,R1
        JNZ     ??GAPBondMgr_LinkEst_3
//  541     {
//  542       if ( osal_isbufset( signingInfo.srk, 0xFF, KEYLEN ) == FALSE )
        ; Setup parameters for call to function osal_isbufset
        MOV     R4,#0x10
        MOV     R1,#-0x1
        MOV     A,#0xc
        LCALL   ?XSTACK_DISP0_8
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??osal_isbufset?relay
        MOV     A,R1
        JNZ     ??GAPBondMgr_LinkEst_3
//  543       {
//  544         // Load the signing information for this connection
//  545         VOID osal_snv_read( devSignCounterNvID(idx), sizeof ( uint32 ), &(signingInfo.signCounter) );
        ; Setup parameters for call to function osal_snv_read
        MOV     A,#0x1c
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,#0x4
        MOV     A,#0x25
        ADD     A,?V0 + 1
        MOV     R1,A
        LCALL   ??osal_snv_read?relay
//  546         VOID GAP_Signable( connHandle,
//  547                           ((stateFlags & GAP_BONDED_STATE_AUTHENTICATED) ? TRUE : FALSE),
//  548                           &signingInfo );
        ; Setup parameters for call to function GAP_Signable
        MOV     A,#0xc
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     A,R7
        MOV     C,0xE0 /* A   */.0
        CLR     A
        RLC     A
        MOV     R1,A
        MOV     R2,?V0 + 2
        MOV     R3,?V0 + 3
        LCALL   ??GAP_Signable?relay
//  549       }
//  550     }
//  551 
//  552     // Load the characteristic configuration
//  553     if ( osal_snv_read( gattCfgNvID(idx), sizeof ( charCfg ), charCfg ) == SUCCESS )
??GAPBondMgr_LinkEst_3:
        ; Setup parameters for call to function osal_snv_read
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,#0xc
        MOV     A,#0x70
        ADD     A,?V0 + 0
        MOV     R1,A
        LCALL   ??osal_snv_read?relay
        MOV     A,R1
        JNZ     ??GAPBondMgr_LinkEst_4
//  554     {
//  555       gapBondMgrInvertCharCfgItem( charCfg );
        ; Setup parameters for call to function gapBondMgrInvertCharCfgItem
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??gapBondMgrInvertCharCfgItem?relay
//  556 
//  557       for ( uint8 i = 0; i < GAP_CHAR_CFG_MAX; i++ )
        MOV     ?V0 + 0,#0x0
//  558       {
//  559         gapBondCharCfg_t *pItem = &(charCfg[i]);
??GAPBondMgr_LinkEst_5:
        MOV     A,?V0 + 0
        MOV     B,#0x3
        MUL     AB
        MOV     R0,A
        MOV     R1,B
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,DPL
        ADD     A,R0
        MOV     R0,A
        MOV     A,DPH
        LCALL   ?Subroutine16 & 0xFFFF
//  560 
//  561         // Apply the characteristic configuration for this connection
//  562         if ( pItem->attrHandle != GATT_INVALID_HANDLE )
??CrossCallReturnLabel_26:
        LCALL   ?Subroutine10 & 0xFFFF
??CrossCallReturnLabel_9:
        JZ      ??GAPBondMgr_LinkEst_6
//  563         {
//  564           VOID GATTServApp_UpdateCharCfg( connHandle, pItem->attrHandle,
//  565                                           (uint16)(pItem->value) );
        ; Setup parameters for call to function GATTServApp_UpdateCharCfg
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 6,A
        MOV     ?V0 + 7,#0x0
        MOV     R0,#?V0 + 6
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     R2,?V0 + 2
        MOV     R3,?V0 + 3
        LCALL   ??GATTServApp_UpdateCharCfg?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
//  566         }
//  567       }
??GAPBondMgr_LinkEst_6:
        INC     ?V0 + 0
        MOV     A,?V0 + 0
        CLR     C
        SUBB    A,#0x4
        JC      ??GAPBondMgr_LinkEst_5
//  568     }
//  569 
//  570     // Has there been a service change?
//  571     if ( stateFlags & GAP_BONDED_STATE_SERVICE_CHANGED )
??GAPBondMgr_LinkEst_4:
        MOV     A,R7
        MOV     C,0xE0 /* A   */.1
        JNC     ??GAPBondMgr_LinkEst_0
//  572     {
//  573       VOID GATTServApp_SendServiceChangedInd( connHandle, gapBondMgr_TaskID );
        ; Setup parameters for call to function GATTServApp_SendServiceChangedInd
        MOV     DPTR,#gapBondMgr_TaskID
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     R2,?V0 + 2
        MOV     R3,?V0 + 3
        LCALL   ??GATTServApp_SendServiceChangedInd?relay
//  574     }
//  575   }
//  576 #if ( HOST_CONFIG & CENTRAL_CFG )
//  577   else if ( role == GAP_PROFILE_CENTRAL &&
//  578             gapBond_PairingMode == GAPBOND_PAIRING_MODE_INITIATE )
//  579   {
//  580     // If Central and initiating and not bonded, then initiate pairing
//  581     gapBondMgrAuthenticate( connHandle, addrType, NULL );
//  582 
//  583     // Call app state callback
//  584     if ( pGapBondCB && pGapBondCB->pairStateCB )
//  585     {
//  586       pGapBondCB->pairStateCB( connHandle, GAPBOND_PAIRING_STATE_STARTED, SUCCESS );
//  587     }
//  588   }
//  589 #endif
//  590 
//  591 #if ( HOST_CONFIG & PERIPHERAL_CFG )
//  592   // If Peripheral and initiating, send a slave security request to
//  593   // initiate either pairing or encryption
//  594   if ( role == GAP_PROFILE_PERIPHERAL &&
//  595        gapBond_PairingMode == GAPBOND_PAIRING_MODE_INITIATE )
??GAPBondMgr_LinkEst_0:
        MOV     A,#0x4
        XRL     A,R6
        JNZ     ??GAPBondMgr_LinkEst_7
        MOV     DPTR,#gapBond_PairingMode
        MOVX    A,@DPTR
        XRL     A,#0x2
        JNZ     ??GAPBondMgr_LinkEst_7
//  596   {
//  597     gapBondMgrSlaveSecurityReq( connHandle );
        MOV     R2,#0x0
        MOV     DPTR,#gapBond_Bonding
        MOVX    A,@DPTR
        JZ      ??GAPBondMgr_LinkEst_8
        INC     R2
??GAPBondMgr_LinkEst_8:
        MOV     DPTR,#gapBond_MITM
        MOVX    A,@DPTR
        JZ      ??GAPBondMgr_LinkEst_9
        MOV     R0,#0x4
        SJMP    ??GAPBondMgr_LinkEst_10
??GAPBondMgr_LinkEst_9:
        MOV     R0,#0x0
??GAPBondMgr_LinkEst_10:
        ; Setup parameters for call to function GAP_SendSlaveSecurityRequest
        MOV     A,R0
        ORL     A,R2
        MOV     R1,A
        MOV     R2,?V0 + 2
        MOV     R3,?V0 + 3
        LCALL   ??GAP_SendSlaveSecurityRequest?relay
//  598   }
//  599 #endif
//  600 
//  601   return ( SUCCESS );
??GAPBondMgr_LinkEst_7:
        MOV     R1,#0x0
        MOV     A,#0x34
        LCALL   ?DEALLOC_XSTACK8
        REQUIRE ?Subroutine1
        ; // Fall through to label ?Subroutine1
//  602 }

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine1:
        MOV     R7,#0x8
        LJMP    ?BANKED_LEAVE_XDATA
//  603 
//  604 /*********************************************************************
//  605  * @brief   Resolve an address from bonding information.
//  606  *
//  607  * Public function defined in gapbondmgr.h.
//  608  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  609 uint8 GAPBondMgr_ResolveAddr( uint8 addrType, uint8 *pDevAddr, uint8 *pResolvedAddr )
GAPBondMgr_ResolveAddr:
        CODE
//  610 {
        MOV     A,#-0x10
        LCALL   ?BANKED_ENTER_XDATA
        ; Saved register size: 16
        ; Auto size: 0
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
        MOV     ?V0 + 0,R4
        MOV     ?V0 + 1,R5
//  611   uint8 idx = GAP_BONDINGS_MAX;
        MOV     ?V0 + 2,#0xa
//  612 
//  613   switch ( addrType )
        MOV     A,R1
        JZ      ??GAPBondMgr_ResolveAddr_0
        DEC     A
        JZ      ??GAPBondMgr_ResolveAddr_0
        DEC     A
        JZ      ??GAPBondMgr_ResolveAddr_1
        DEC     A
        JZ      ??GAPBondMgr_ResolveAddr_2
        LJMP    ??GAPBondMgr_ResolveAddr_3 & 0xFFFF
//  614   {
//  615     case ADDRTYPE_PUBLIC:
//  616     case ADDRTYPE_STATIC:
//  617       idx = gapBondMgrFindAddr( pDevAddr );
??GAPBondMgr_ResolveAddr_0:
        ; Setup parameters for call to function gapBondMgrFindAddr
        LCALL   ??gapBondMgrFindAddr?relay
        MOV     A,R1
        MOV     ?V0 + 2,A
//  618       if ( (idx < GAP_BONDINGS_MAX) && (pResolvedAddr) )
        CLR     C
        SUBB    A,#0xa
        JC      $+5
        LJMP    ??GAPBondMgr_ResolveAddr_3 & 0xFFFF
        MOV     A,?V0 + 0
        ORL     A,?V0 + 1
        JZ      ??GAPBondMgr_ResolveAddr_3
//  619       {
//  620         VOID osal_memcpy( pResolvedAddr, pDevAddr, B_ADDR_LEN );
        ; Setup parameters for call to function osal_memcpy
        MOV     ?V0 + 6,#0x6
        MOV     ?V0 + 7,#0x0
        MOV     R0,#?V0 + 6
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     A,R6
        MOV     R4,A
        MOV     A,R7
        MOV     R5,A
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
        LCALL   ??osal_memcpy?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        SJMP    ??GAPBondMgr_ResolveAddr_3
//  621       }
//  622       break;
//  623 
//  624     case ADDRTYPE_PRIVATE_NONRESOLVE:
//  625       // This could be a reconnection address
//  626       idx = gapBondMgrFindReconnectAddr( pDevAddr );
??GAPBondMgr_ResolveAddr_1:
        MOV     ?V0 + 3,#0x0
??GAPBondMgr_ResolveAddr_4:
        ; Setup parameters for call to function osal_memcmp
        MOV     ?V0 + 6,#0x6
        MOV     ?V0 + 7,#0x0
        MOV     R0,#?V0 + 6
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     A,R6
        MOV     R4,A
        MOV     A,R7
        MOV     R5,A
        MOV     A,?V0 + 3
        MOV     B,#0xe
        MUL     AB
        MOV     R0,A
        MOV     R1,B
        MOV     A,#(bonds + 6) & 0xff
        ADD     A,R0
        MOV     R2,A
        MOV     A,#((bonds + 6) >> 8) & 0xff
        ADDC    A,R1
        MOV     R3,A
        LCALL   ??osal_memcmp?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        MOV     A,R1
        JZ      ??GAPBondMgr_ResolveAddr_5
        MOV     ?V0 + 2,?V0 + 3
//  627       if ( (idx < GAP_BONDINGS_MAX) && (pResolvedAddr) )
        MOV     A,?V0 + 2
        CLR     C
        SUBB    A,#0xa
        JNC     ??GAPBondMgr_ResolveAddr_3
        SJMP    ??GAPBondMgr_ResolveAddr_6
??GAPBondMgr_ResolveAddr_5:
        INC     ?V0 + 3
        MOV     A,?V0 + 3
        CLR     C
        SUBB    A,#0xa
        JNC     ??GAPBondMgr_ResolveAddr_3
        SJMP    ??GAPBondMgr_ResolveAddr_4
//  628       {
//  629         VOID gapBondMgrGetPublicAddr( idx, pResolvedAddr );
//  630       }
//  631       break;
//  632 
//  633     case ADDRTYPE_PRIVATE_RESOLVE:
//  634       // Master's don't use Private Resolvable addresses but just in case
//  635       idx = gapBondMgrResolvePrivateAddr( pDevAddr );
??GAPBondMgr_ResolveAddr_2:
        ; Setup parameters for call to function gapBondMgrResolvePrivateAddr
        LCALL   ??gapBondMgrResolvePrivateAddr?relay
        MOV     A,R1
        MOV     ?V0 + 2,A
//  636       if ( (idx < GAP_BONDINGS_MAX) && (pResolvedAddr) )
        CLR     C
        SUBB    A,#0xa
        JNC     ??GAPBondMgr_ResolveAddr_3
??GAPBondMgr_ResolveAddr_6:
        MOV     A,?V0 + 0
        ORL     A,?V0 + 1
        JZ      ??GAPBondMgr_ResolveAddr_3
//  637       {
//  638         VOID gapBondMgrGetPublicAddr( idx, pResolvedAddr );
        ; Setup parameters for call to function gapBondMgrGetPublicAddr
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
        MOV     R1,?V0 + 2
        LCALL   ??gapBondMgrGetPublicAddr?relay
//  639       }
//  640       break;
//  641 
//  642     default:
//  643       break;
//  644   }
//  645 
//  646   return ( idx );
??GAPBondMgr_ResolveAddr_3:
        MOV     R1,?V0 + 2
        LJMP    ?Subroutine1 & 0xFFFF
//  647 }
//  648 
//  649 /*********************************************************************
//  650  * @brief   Set/clear the service change indication in a bond record.
//  651  *
//  652  * Public function defined in gapbondmgr.h.
//  653  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  654 bStatus_t GAPBondMgr_ServiceChangeInd( uint16 connectionHandle, uint8 setParam )
GAPBondMgr_ServiceChangeInd:
        CODE
//  655 {
        MOV     A,#-0xc
        LCALL   ?BANKED_ENTER_XDATA
        ; Saved register size: 12
        ; Auto size: 0
        MOV     ?V0 + 0,R1
//  656   bStatus_t ret = bleNoResources; // return value
        MOV     ?V0 + 1,#0x15
//  657 
//  658   if ( connectionHandle == 0xFFFF )
        MOV     A,#-0x1
        XRL     A,R2
        JNZ     ??GAPBondMgr_ServiceChangeInd_0
        MOV     A,#-0x1
        XRL     A,R3
??GAPBondMgr_ServiceChangeInd_0:
        JNZ     ??GAPBondMgr_ServiceChangeInd_1
//  659   {
//  660     uint8 idx;  // loop counter
//  661 
//  662     // Run through the bond database and update the Service Change indication
//  663     for ( idx = 0; idx < GAP_BONDINGS_MAX; idx++ )
        MOV     R6,#0x0
//  664     {
//  665       if ( gapBondMgrChangeState( idx, GAP_BONDED_STATE_SERVICE_CHANGED, setParam ) )
??GAPBondMgr_ServiceChangeInd_2:
        ; Setup parameters for call to function gapBondMgrChangeState
        MOV     R4,?V0 + 0
        MOV     R2,#0x2
        MOV     R3,#0x0
        MOV     A,R6
        MOV     R1,A
        LCALL   ??gapBondMgrChangeState?relay
        MOV     A,R1
        JZ      ??GAPBondMgr_ServiceChangeInd_3
//  666       {
//  667         ret = SUCCESS;
        MOV     ?V0 + 1,#0x0
//  668       }
//  669     }
??GAPBondMgr_ServiceChangeInd_3:
        INC     R6
        MOV     A,R6
        CLR     C
        SUBB    A,#0xa
        JC      ??GAPBondMgr_ServiceChangeInd_2
//  670 
//  671     // If the service change indication is TRUE, tell the connected devices
//  672     if ( setParam )
        MOV     A,?V0 + 0
        JZ      ??GAPBondMgr_ServiceChangeInd_4
//  673     {
//  674       // Run connected database
//  675       linkDB_PerformFunc( gapBondMgrSendServiceChange );
        ; Setup parameters for call to function linkDB_PerformFunc
        MOV     R2,#??gapBondMgrSendServiceChange?relay & 0xff
        MOV     R3,#(??gapBondMgrSendServiceChange?relay >> 8) & 0xff
        LCALL   ??linkDB_PerformFunc?relay
        SJMP    ??GAPBondMgr_ServiceChangeInd_4
//  676     }
//  677   }
//  678   else
//  679   {
//  680     // Find connection information
//  681     linkDBItem_t *pLinkItem = linkDB_Find( connectionHandle );
??GAPBondMgr_ServiceChangeInd_1:
        ; Setup parameters for call to function linkDB_Find
        LCALL   ??linkDB_Find?relay
        MOV     ?V0 + 2,R2
        MOV     ?V0 + 3,R3
        MOV     R6,?V0 + 2
        MOV     R7,?V0 + 3
//  682     if ( pLinkItem )
        MOV     A,R6
        ORL     A,R7
        JZ      ??GAPBondMgr_ServiceChangeInd_5
//  683     {
//  684       uint8 idx; // loop counter
//  685       idx = GAPBondMgr_ResolveAddr( pLinkItem->addrType, pLinkItem->addr, NULL );
        ; Setup parameters for call to function GAPBondMgr_ResolveAddr
        MOV     R4,#0x0
        MOV     R5,#0x0
        MOV     A,R6
        ADD     A,#0x5
        MOV     R2,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     R3,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??GAPBondMgr_ResolveAddr?relay
        MOV     A,R1
//  686       if ( idx < GAP_BONDINGS_MAX )
        CLR     C
        SUBB    A,#0xa
        JNC     ??GAPBondMgr_ServiceChangeInd_6
//  687       {
//  688         // Bond found, update it.
//  689         VOID gapBondMgrChangeState( idx, GAP_BONDED_STATE_SERVICE_CHANGED, setParam );
        ; Setup parameters for call to function gapBondMgrChangeState
        MOV     R4,?V0 + 0
        MOV     R2,#0x2
        MOV     R3,#0x0
        LCALL   ??gapBondMgrChangeState?relay
//  690         ret = SUCCESS;
        MOV     ?V0 + 1,#0x0
//  691       }
//  692 
//  693       // If the service change indication is TRUE, tell the connected device
//  694       if ( setParam )
??GAPBondMgr_ServiceChangeInd_6:
        MOV     A,?V0 + 0
        JZ      ??GAPBondMgr_ServiceChangeInd_4
//  695       {
//  696         gapBondMgrSendServiceChange( pLinkItem );
        ; Setup parameters for call to function gapBondMgrSendServiceChange
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   ??gapBondMgrSendServiceChange?relay
        SJMP    ??GAPBondMgr_ServiceChangeInd_4
//  697       }
//  698     }
//  699     else
//  700     {
//  701       ret = bleNotConnected;
??GAPBondMgr_ServiceChangeInd_5:
        MOV     ?V0 + 1,#0x14
//  702     }
//  703   }
//  704 
//  705   return ( ret );
??GAPBondMgr_ServiceChangeInd_4:
        MOV     R1,?V0 + 1
        LJMP    ??Subroutine20_0 & 0xFFFF
//  706 }
//  707 
//  708 /*********************************************************************
//  709  * @brief   Update the Characteristic Configuration in a bond record.
//  710  *
//  711  * Public function defined in gapbondmgr.h.
//  712  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  713 bStatus_t GAPBondMgr_UpdateCharCfg( uint16 connectionHandle, uint16 attrHandle, uint16 value )
GAPBondMgr_UpdateCharCfg:
        CODE
//  714 {
        MOV     A,#-0xe
        LCALL   ?BANKED_ENTER_XDATA
        ; Saved register size: 14
        ; Auto size: 0
        MOV     A,R4
        MOV     R6,A
        MOV     A,R5
        MOV     R7,A
//  715   bStatus_t ret = bleNoResources; // return value
        MOV     ?V0 + 0,#0x15
        MOV     A,#0xe
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 3,A
//  716 
//  717   if ( connectionHandle == INVALID_CONNHANDLE )
        MOV     A,#-0x1
        XRL     A,R2
        JNZ     ??GAPBondMgr_UpdateCharCfg_0
        MOV     A,#-0x1
        XRL     A,R3
??GAPBondMgr_UpdateCharCfg_0:
        JNZ     ??GAPBondMgr_UpdateCharCfg_1
//  718   {
//  719     uint8 idx;  // loop counter
//  720 
//  721     // Run through the bond database and update the Characteristic Configuration
//  722     for ( idx = 0; idx < GAP_BONDINGS_MAX; idx++ )
        MOV     ?V0 + 1,#0x0
//  723     {
//  724       if ( gapBondMgrUpdateCharCfg( idx, attrHandle, value ) )
??GAPBondMgr_UpdateCharCfg_2:
        ; Setup parameters for call to function gapBondMgrUpdateCharCfg
        MOV     R4,?V0 + 2
        MOV     R5,?V0 + 3
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        MOV     R1,?V0 + 1
        LCALL   ??gapBondMgrUpdateCharCfg?relay
        MOV     A,R1
        JZ      ??GAPBondMgr_UpdateCharCfg_3
//  725       {
//  726         ret = SUCCESS;
        MOV     ?V0 + 0,#0x0
//  727       }
//  728     }
??GAPBondMgr_UpdateCharCfg_3:
        INC     ?V0 + 1
        MOV     A,?V0 + 1
        CLR     C
        SUBB    A,#0xa
        JNC     ??GAPBondMgr_UpdateCharCfg_4
        SJMP    ??GAPBondMgr_UpdateCharCfg_2
//  729   }
//  730   else
//  731   {
//  732     // Find connection information
//  733     linkDBItem_t *pLinkItem = linkDB_Find( connectionHandle );
??GAPBondMgr_UpdateCharCfg_1:
        ; Setup parameters for call to function linkDB_Find
        LCALL   ??linkDB_Find?relay
        MOV     DPL,R2
        MOV     DPH,R3
//  734     if ( pLinkItem )
        MOV     A,DPL
        ORL     A,DPH
        JZ      ??GAPBondMgr_UpdateCharCfg_5
//  735     {
//  736       uint8 idx = GAPBondMgr_ResolveAddr( pLinkItem->addrType, pLinkItem->addr, NULL );
        ; Setup parameters for call to function GAPBondMgr_ResolveAddr
        MOV     R4,#0x0
        MOV     R5,#0x0
        MOV     A,DPL
        ADD     A,#0x5
        MOV     R2,A
        MOV     A,DPH
        ADDC    A,#0x0
        MOV     R3,A
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??GAPBondMgr_ResolveAddr?relay
        MOV     A,R1
//  737       if ( idx < GAP_BONDINGS_MAX )
        CLR     C
        SUBB    A,#0xa
        JNC     ??GAPBondMgr_UpdateCharCfg_4
//  738       {
//  739         // Bond found, update it.
//  740         VOID gapBondMgrUpdateCharCfg( idx, attrHandle, value );
        ; Setup parameters for call to function gapBondMgrUpdateCharCfg
        MOV     R4,?V0 + 2
        MOV     R5,?V0 + 3
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   ??gapBondMgrUpdateCharCfg?relay
//  741         ret = SUCCESS;
        MOV     ?V0 + 0,#0x0
        SJMP    ??GAPBondMgr_UpdateCharCfg_4
//  742       }
//  743     }
//  744     else
//  745     {
//  746       ret = bleNotConnected;
??GAPBondMgr_UpdateCharCfg_5:
        MOV     ?V0 + 0,#0x14
//  747     }
//  748   }
//  749 
//  750   return ( ret );
??GAPBondMgr_UpdateCharCfg_4:
        MOV     R1,?V0 + 0
        LJMP    ??Subroutine21_0 & 0xFFFF
//  751 }
//  752 
//  753 /*********************************************************************
//  754  * @brief   Register callback functions with the bond manager.
//  755  *
//  756  * Public function defined in gapbondmgr.h.
//  757  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  758 void GAPBondMgr_Register( gapBondCBs_t *pCB )
GAPBondMgr_Register:
        CODE
//  759 {
        PUSH    DPL
        PUSH    DPH
        ; Saved register size: 2
        ; Auto size: 0
//  760   pGapBondCB = pCB;
        MOV     DPTR,#pGapBondCB
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
//  761 
//  762   // Take over the processing of Authentication messages
//  763   VOID GAP_SetParamValue( TGAP_AUTH_TASK_ID, gapBondMgr_TaskID );
        ; Setup parameters for call to function GAP_SetParamValue
        MOV     DPTR,#gapBondMgr_TaskID
        MOVX    A,@DPTR
        MOV     R4,A
        MOV     R5,#0x0
        MOV     R2,#0x23
        MOV     R3,#0x0
        LCALL   ??GAP_SetParamValue?relay
//  764 
//  765   // Register with GATT Server App for event messages
//  766   GATTServApp_RegisterForMsg( gapBondMgr_TaskID );
        ; Setup parameters for call to function GATTServApp_RegisterForMsg
        MOV     DPTR,#gapBondMgr_TaskID
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??GATTServApp_RegisterForMsg?relay
//  767 }
        REQUIRE ?Subroutine3
        ; // Fall through to label ?Subroutine3

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine3:
        POP     DPH
        POP     DPL
        LJMP    ?BRET
//  768 
//  769 /*********************************************************************
//  770  * @brief   Respond to a passcode request.
//  771  *
//  772  * Public function defined in gapbondmgr.h.
//  773  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  774 bStatus_t GAPBondMgr_PasscodeRsp( uint16 connectionHandle, uint8 status, uint32 passcode )
GAPBondMgr_PasscodeRsp:
        CODE
//  775 {
        MOV     A,#-0x14
        LCALL   ?BANKED_ENTER_XDATA
        ; Saved register size: 20
        ; Auto size: 0
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     A,R1
        MOV     R6,A
        MOV     A,#0x14
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 4
        LCALL   ?L_MOV_X
//  776   bStatus_t ret = SUCCESS;
        MOV     R7,#0x0
//  777 
//  778   if ( status == SUCCESS )
        MOV     A,R6
        JNZ     ??GAPBondMgr_PasscodeRsp_0
//  779   {
//  780     // Truncate the passcode
//  781     passcode = passcode % (GAP_PASSCODE_MAX + 1);
//  782 
//  783     ret = GAP_PasscodeUpdate( passcode, connectionHandle );
        ; Setup parameters for call to function GAP_PasscodeUpdate
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     DPTR,#__Constant_f4240
        MOV     R0,#?V0 + 8
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 4
        MOV     R1,#?V0 + 8
        LCALL   ?UL_DIV_MOD
        MOV     R2,?V0 + 8
        MOV     R3,?V0 + 9
        MOV     R4,?V0 + 10
        MOV     R5,?V0 + 11
        LCALL   ??GAP_PasscodeUpdate?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        MOV     A,R1
        MOV     R7,A
//  784     if ( ret != SUCCESS )
        JZ      ??GAPBondMgr_PasscodeRsp_1
//  785     {
//  786       VOID GAP_TerminateAuth( connectionHandle, SMP_PAIRING_FAILED_PASSKEY_ENTRY_FAILED );
        ; Setup parameters for call to function GAP_TerminateAuth
        MOV     R1,#0x1
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
//  787     }
//  788   }
//  789   else
//  790   {
//  791     VOID GAP_TerminateAuth( connectionHandle, status );
??GAPBondMgr_PasscodeRsp_0:
        ; Setup parameters for call to function GAP_TerminateAuth
        LCALL   ??GAP_TerminateAuth?relay
//  792   }
//  793 
//  794   return ret;
??GAPBondMgr_PasscodeRsp_1:
        MOV     A,R7
        MOV     R1,A
        MOV     R7,#0xc
        LJMP    ?BANKED_LEAVE_XDATA
//  795 }
//  796 
//  797 /*********************************************************************
//  798  * @brief   This is a bypass mechanism to allow the bond manager to process
//  799  *              GAP messages.
//  800  *
//  801  * Public function defined in gapbondmgr.h.
//  802  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  803 void GAPBondMgr_ProcessGAPMsg( gapEventHdr_t *pMsg )
GAPBondMgr_ProcessGAPMsg:
        CODE
//  804 {
        MOV     A,#-0x16
        LCALL   ?BANKED_ENTER_XDATA
        ; Saved register size: 22
        ; Auto size: 20
        MOV     A,#-0x14
        LCALL   ?ALLOC_XSTACK8
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
//  805   switch ( pMsg->opcode )
        MOV     A,R6
        ADD     A,#0xc
        MOV     ?V0 + 12,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     ?V0 + 13,A
        MOV     A,R6
        ADD     A,#0xa
        MOV     ?V0 + 4,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     ?V0 + 5,A
        MOV     A,R6
        ADD     A,#0x5
        MOV     ?V0 + 6,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     ?V0 + 7,A
        MOV     A,R6
        ADD     A,#0x9
        MOV     ?V0 + 2,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     ?V0 + 3,A
        MOV     A,R6
        ADD     A,#0x3
        MOV     ?V0 + 0,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     ?V0 + 1,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        ADD     A,#-0x6
        JNZ     $+5
        LJMP    ??GAPBondMgr_ProcessGAPMsg_0 & 0xFFFF
        ADD     A,#-0x3
        JNZ     $+5
        LJMP    ??GAPBondMgr_ProcessGAPMsg_1 & 0xFFFF
        DEC     A
        JNZ     $+5
        LJMP    ??GAPBondMgr_ProcessGAPMsg_2 & 0xFFFF
        DEC     A
        JZ      ??GAPBondMgr_ProcessGAPMsg_3
        ADD     A,#-0x3
        JNZ     $+5
        LJMP    ??GAPBondMgr_ProcessGAPMsg_4 & 0xFFFF
        DEC     A
        JNZ     $+5
        LJMP    ??GAPBondMgr_ProcessGAPMsg_5 & 0xFFFF
        LJMP    ??GAPBondMgr_ProcessGAPMsg_6 & 0xFFFF
//  806   {
//  807     case GAP_PASSKEY_NEEDED_EVENT:
//  808       {
//  809         gapPasskeyNeededEvent_t *pPkt = (gapPasskeyNeededEvent_t *)pMsg;
//  810 
//  811         if ( pGapBondCB && pGapBondCB->passcodeCB )
??GAPBondMgr_ProcessGAPMsg_3:
        LCALL   ?Subroutine9 & 0xFFFF
??CrossCallReturnLabel_2:
        JZ      ??GAPBondMgr_ProcessGAPMsg_7
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        LCALL   ?Subroutine11 & 0xFFFF
??CrossCallReturnLabel_12:
        MOV     ?V0 + 4,R0
        MOV     ?V0 + 5,R1
        MOV     A,R0
        ORL     A,?V0 + 5
        JZ      ??GAPBondMgr_ProcessGAPMsg_7
//  812         {
//  813           // Ask app for a passcode
//  814           pGapBondCB->passcodeCB( pPkt->deviceAddr, pPkt->connectionHandle, pPkt->uiInputs, pPkt->uiOutputs );
        ; Setup parameters for indirect call
        MOV     DPL,?V0 + 12
        MOV     DPH,?V0 + 13
        MOVX    A,@DPTR
        MOV     ?V0 + 6,A
        MOV     R0,#?V0 + 6
        LCALL   ?PUSH_XSTACK_I_ONE
        MOV     A,R6
        ADD     A,#0xb
        MOV     DPL,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        LCALL   ??Subroutine25_0 & 0xFFFF
//  815         }
??CrossCallReturnLabel_48:
        INC     R2
        INC     R2
        INC     R2
        MOV     R3,?V0 + 1
        MOV     DPL,?V0 + 4
        MOV     DPH,?V0 + 5
        LCALL   ?CALL_IND
        MOV     A,#0x1
        LCALL   ?DEALLOC_XSTACK8
        LJMP    ??GAPBondMgr_ProcessGAPMsg_6 & 0xFFFF
//  816         else
//  817         {
//  818           // No app support, use the default passcode
//  819           if ( GAP_PasscodeUpdate( gapBond_Passcode, pPkt->connectionHandle ) != SUCCESS )
??GAPBondMgr_ProcessGAPMsg_7:
        ; Setup parameters for call to function GAP_PasscodeUpdate
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        LCALL   ?PUSH_XSTACK8_X_TWO
        MOV     DPTR,#gapBond_Passcode
        LCALL   ?XLOAD_R2345
        LCALL   ??GAP_PasscodeUpdate?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        MOV     A,R1
        JNZ     $+5
        LJMP    ??GAPBondMgr_ProcessGAPMsg_6 & 0xFFFF
//  820           {
//  821             VOID GAP_TerminateAuth( pPkt->connectionHandle, SMP_PAIRING_FAILED_PASSKEY_ENTRY_FAILED );
        ; Setup parameters for call to function GAP_TerminateAuth
        MOV     R1,#0x1
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        LJMP    ??GAPBondMgr_ProcessGAPMsg_8 & 0xFFFF
//  822           }
//  823         }
//  824       }
//  825       break;
//  826 
//  827     case GAP_AUTHENTICATION_COMPLETE_EVENT:
//  828       {
//  829         gapAuthCompleteEvent_t *pPkt = (gapAuthCompleteEvent_t *)pMsg;
//  830 
//  831         // Should we save bonding information
//  832         if ( (pPkt->hdr.status == SUCCESS) && (pPkt->authState & SM_AUTH_STATE_BONDING) )
??GAPBondMgr_ProcessGAPMsg_2:
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     ?V0 + 10,DPL
        MOV     ?V0 + 11,DPH
        MOVX    A,@DPTR
        JZ      $+5
        LJMP    ??GAPBondMgr_ProcessGAPMsg_9 & 0xFFFF
        MOV     DPL,?V0 + 6
        MOV     DPH,?V0 + 7
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.0
        JC      $+5
        LJMP    ??GAPBondMgr_ProcessGAPMsg_9 & 0xFFFF
//  833         {
//  834           gapBondRec_t bondRec;
//  835 
//  836           VOID osal_memset( &bondRec, 0, sizeof ( gapBondRec_t ) ) ;
        ; Setup parameters for call to function osal_memset
        MOV     R4,#0xe
        MOV     R5,#0x0
        MOV     R1,#0x0
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??osal_memset?relay
//  837 
//  838           // Do we have a public address in the data?
//  839           if ( pPkt->pIdentityInfo )
        MOV     A,R6
        ADD     A,#0x8
        MOV     ?V0 + 8,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     ?V0 + 9,A
        MOV     DPL,?V0 + 8
        MOV     DPH,A
        LCALL   ??Subroutine23_0 & 0xFFFF
??CrossCallReturnLabel_35:
        MOV     A,R2
        ORL     A,R3
        JZ      ??GAPBondMgr_ProcessGAPMsg_10
//  840           {
//  841             VOID osal_memcpy( bondRec.publicAddr, pPkt->pIdentityInfo->bd_addr, B_ADDR_LEN );
        ; Setup parameters for call to function osal_memcpy
        MOV     ?V0 + 2,#0x6
        MOV     ?V0 + 3,#0x0
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     A,R2
        ADD     A,#0x10
        SJMP    ??GAPBondMgr_ProcessGAPMsg_11
//  842           }
//  843           else
//  844           {
//  845             linkDBItem_t *pLinkItem = linkDB_Find( pPkt->connectionHandle );
??GAPBondMgr_ProcessGAPMsg_10:
        ; Setup parameters for call to function linkDB_Find
        LCALL   ?Subroutine7 & 0xFFFF
??CrossCallReturnLabel_40:
        LCALL   ??linkDB_Find?relay
//  846             if ( pLinkItem )
        MOV     A,R2
        ORL     A,R3
        JNZ     $+5
        LJMP    ??GAPBondMgr_ProcessGAPMsg_6 & 0xFFFF
//  847             {
//  848               VOID osal_memcpy( bondRec.publicAddr, pLinkItem->addr, B_ADDR_LEN );
        ; Setup parameters for call to function osal_memcpy
        MOV     ?V0 + 2,#0x6
        MOV     ?V0 + 3,#0x0
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     A,R2
        ADD     A,#0x5
??GAPBondMgr_ProcessGAPMsg_11:
        MOV     R4,A
        MOV     A,R3
        ADDC    A,#0x0
        MOV     R5,A
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??osal_memcpy?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
//  849             }
//  850             else
//  851             {
//  852               // We don't have an address, so ignore the message.
//  853               break;
//  854             }
//  855           }
//  856 
//  857           // Save off of the authentication state
//  858           bondRec.stateFlags |= (pPkt->authState & SM_AUTH_STATE_AUTHENTICATED) ? GAP_BONDED_STATE_AUTHENTICATED : 0;
        MOV     DPL,?V0 + 6
        MOV     DPH,?V0 + 7
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.2
        JNC     ??GAPBondMgr_ProcessGAPMsg_12
        SETB    B.0
        SJMP    ??GAPBondMgr_ProcessGAPMsg_13
??GAPBondMgr_ProcessGAPMsg_12:
        CLR     B.0
??GAPBondMgr_ProcessGAPMsg_13:
        MOV     C,B.0
        CLR     A
        RLC     A
        MOV     R0,A
        MOV     A,#0xc
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ORL     A,R0
        MOVX    @DPTR,A
//  859 
//  860           VOID gapBondMgrAddBond( &bondRec,
//  861                              (gapBondLTK_t *)pPkt->pSecurityInfo,
//  862                              (gapBondLTK_t *)pPkt->pDevSecInfo,
//  863                              ((uint8 *)((pPkt->pIdentityInfo) ? pPkt->pIdentityInfo->irk : NULL )),
//  864                              ((uint8 *)((pPkt->pSigningInfo) ? pPkt->pSigningInfo->srk : NULL )),
//  865                              ((uint32)((pPkt->pSigningInfo) ? pPkt->pSigningInfo->signCounter : GAP_INIT_SIGN_COUNTER )) );
        MOV     DPL,?V0 + 4
        MOV     DPH,?V0 + 5
        MOVX    A,@DPTR
        MOV     ?V0 + 2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 3,A
        MOV     A,?V0 + 2
        ORL     A,?V0 + 3
        JZ      ??GAPBondMgr_ProcessGAPMsg_14
        MOV     A,?V0 + 2
        ADD     A,#0x10
        MOV     DPL,A
        MOV     A,?V0 + 3
        ADDC    A,#0x0
        MOV     DPH,A
        MOV     R0,#?V0 + 4
        LCALL   ?L_MOV_X
        SJMP    ??GAPBondMgr_ProcessGAPMsg_15
??GAPBondMgr_ProcessGAPMsg_14:
        MOV     ?V0 + 4,#-0x1
        MOV     ?V0 + 5,#-0x1
        MOV     ?V0 + 6,#-0x1
        MOV     ?V0 + 7,#-0x1
??GAPBondMgr_ProcessGAPMsg_15:
        MOV     A,?V0 + 2
        ORL     A,?V0 + 3
        JNZ     ??GAPBondMgr_ProcessGAPMsg_16
        MOV     ?V0 + 2,#0x0
        MOV     ?V0 + 3,#0x0
??GAPBondMgr_ProcessGAPMsg_16:
        MOV     DPL,?V0 + 8
        MOV     DPH,?V0 + 9
        MOVX    A,@DPTR
        MOV     ?V0 + 8,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 9,A
        MOV     A,?V0 + 8
        ORL     A,?V0 + 9
        JNZ     ??GAPBondMgr_ProcessGAPMsg_17
        MOV     ?V0 + 8,#0x0
        MOV     ?V0 + 9,#0x0
??GAPBondMgr_ProcessGAPMsg_17:
        ; Setup parameters for call to function gapBondMgrAddBond
        MOV     R0,#?V0 + 4
        LCALL   ?PUSH_XSTACK_I_FOUR
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     R0,#?V0 + 8
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     DPL,?V0 + 12
        MOV     DPH,?V0 + 13
        LCALL   ?PUSH_XSTACK8_X_TWO
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        LCALL   ?Subroutine12 & 0xFFFF
??CrossCallReturnLabel_50:
        MOV     A,#0xa
        LCALL   ?XSTACK_DISP0_8
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??gapBondMgrAddBond?relay
        MOV     A,#0xa
        LCALL   ?DEALLOC_XSTACK8
//  866 
//  867           // Update NV to have same CCC values as GATT database
//  868           gapBondMgr_SyncCharCfg( pPkt->connectionHandle );
        ; Setup parameters for call to function gapBondMgr_SyncCharCfg
        LCALL   ?Subroutine7 & 0xFFFF
//  869         }
??CrossCallReturnLabel_41:
        LCALL   ??gapBondMgr_SyncCharCfg?relay
//  870 
//  871         // Call app state callback
//  872         if ( pGapBondCB && pGapBondCB->pairStateCB )
??GAPBondMgr_ProcessGAPMsg_9:
        LCALL   ?Subroutine9 & 0xFFFF
??CrossCallReturnLabel_3:
        JNZ     $+5
        LJMP    ??GAPBondMgr_ProcessGAPMsg_6 & 0xFFFF
        LCALL   ?Subroutine8 & 0xFFFF
??CrossCallReturnLabel_0:
        JNZ     $+5
        LJMP    ??GAPBondMgr_ProcessGAPMsg_6 & 0xFFFF
//  873         {
//  874           pGapBondCB->pairStateCB( pPkt->connectionHandle, GAPBOND_PAIRING_STATE_COMPLETE, pPkt->hdr.status );
        ; Setup parameters for indirect call
        MOV     DPL,?V0 + 10
        MOV     DPH,?V0 + 11
        MOVX    A,@DPTR
        MOV     R4,A
        MOV     R1,#0x1
        LJMP    ??GAPBondMgr_ProcessGAPMsg_18 & 0xFFFF
//  875         }
//  876       }
//  877       break;
//  878 
//  879     case GAP_BOND_COMPLETE_EVENT:
//  880       // This message is received when the bonding is complete.  If hdr.status is SUCCESS
//  881       // then call app state callback.  If hdr.status is NOT SUCCESS, the connection will be
//  882       // dropped at the LL because of a MIC failure, so again nothing to do.
//  883       {
//  884         gapBondCompleteEvent_t *pPkt = (gapBondCompleteEvent_t *)pMsg;
//  885 
//  886         // Update NV to have same CCC values as GATT database
//  887         gapBondMgr_SyncCharCfg( pPkt->connectionHandle );
??GAPBondMgr_ProcessGAPMsg_4:
        ; Setup parameters for call to function gapBondMgr_SyncCharCfg
        LCALL   ?Subroutine7 & 0xFFFF
??CrossCallReturnLabel_42:
        LCALL   ??gapBondMgr_SyncCharCfg?relay
//  888 
//  889         if ( pGapBondCB && pGapBondCB->pairStateCB )
        LCALL   ?Subroutine9 & 0xFFFF
??CrossCallReturnLabel_4:
        JNZ     $+5
        LJMP    ??GAPBondMgr_ProcessGAPMsg_6 & 0xFFFF
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        LCALL   ?Subroutine11 & 0xFFFF
??CrossCallReturnLabel_13:
        MOV     ?V0 + 3,R1
        MOV     A,R0
        ORL     A,?V0 + 3
        JNZ     $+5
        LJMP    ??GAPBondMgr_ProcessGAPMsg_6 & 0xFFFF
//  890         {
//  891           pGapBondCB->pairStateCB( pPkt->connectionHandle, GAPBOND_PAIRING_STATE_BONDED, pMsg->hdr.status );
        ; Setup parameters for indirect call
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R4,A
        MOV     R1,#0x2
        LCALL   ?Subroutine7 & 0xFFFF
//  892         }
//  893       }
??CrossCallReturnLabel_43:
        MOV     DPL,R0
        MOV     DPH,?V0 + 3
        LJMP    ??GAPBondMgr_ProcessGAPMsg_19 & 0xFFFF
//  894       break;
//  895 
//  896     case GAP_SIGNATURE_UPDATED_EVENT:
//  897       {
//  898         uint8 idx;
//  899         gapSignUpdateEvent_t *pPkt = (gapSignUpdateEvent_t *)pMsg;
//  900 
//  901         idx = GAPBondMgr_ResolveAddr( pPkt->addrType, pPkt->devAddr, NULL );
??GAPBondMgr_ProcessGAPMsg_1:
        ; Setup parameters for call to function GAPBondMgr_ResolveAddr
        MOV     R4,#0x0
        MOV     R5,#0x0
        MOV     A,R6
        ADD     A,#0x4
        MOV     R2,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     R3,A
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??GAPBondMgr_ResolveAddr?relay
        MOV     A,R1
        MOV     R0,A
//  902         if ( idx < GAP_BONDINGS_MAX )
        CLR     C
        SUBB    A,#0xa
        JC      $+5
        LJMP    ??GAPBondMgr_ProcessGAPMsg_6 & 0xFFFF
//  903         {
//  904           // Save the sign counter
//  905           VOID osal_snv_write( devSignCounterNvID(idx), sizeof ( uint32 ), &(pPkt->signCounter) );
        ; Setup parameters for call to function osal_snv_write
        MOV     R4,?V0 + 4
        MOV     R5,?V0 + 5
        MOV     R2,#0x4
        MOV     B,#0x6
        MOV     A,R0
        MUL     AB
        ADD     A,#0x25
        MOV     R1,A
        LCALL   ??osal_snv_write?relay
        LJMP    ??GAPBondMgr_ProcessGAPMsg_6 & 0xFFFF
//  906         }
//  907       }
//  908       break;
//  909 
//  910 #if ( HOST_CONFIG & PERIPHERAL_CFG )
//  911     case GAP_PAIRING_REQ_EVENT:
//  912       {
//  913         gapPairingReqEvent_t *pPkt = (gapPairingReqEvent_t *)pMsg;
//  914 
//  915         if ( gapBond_AutoFail != FALSE )
??GAPBondMgr_ProcessGAPMsg_5:
        LCALL   ?Subroutine7 & 0xFFFF
??CrossCallReturnLabel_44:
        MOV     DPTR,#gapBond_AutoFail
        MOVX    A,@DPTR
        JZ      ??GAPBondMgr_ProcessGAPMsg_20
//  916         {
//  917           // Auto Fail TEST MODE (DON'T USE THIS) - Sends pre-setup reason
//  918           VOID GAP_TerminateAuth( pPkt->connectionHandle, gapBond_AutoFailReason );
        ; Setup parameters for call to function GAP_TerminateAuth
        MOV     DPTR,#gapBond_AutoFailReason
        MOVX    A,@DPTR
        MOV     R1,A
        SJMP    ??CrossCallReturnLabel_36
//  919         }
//  920         else if ( gapBond_PairingMode == GAPBOND_PAIRING_MODE_NO_PAIRING )
??GAPBondMgr_ProcessGAPMsg_20:
        MOV     DPTR,#gapBond_PairingMode
        MOVX    A,@DPTR
        JNZ     ??GAPBondMgr_ProcessGAPMsg_21
//  921         {
//  922           // No Pairing - Send error
//  923           VOID GAP_TerminateAuth( pPkt->connectionHandle, SMP_PAIRING_FAILED_NOT_SUPPORTED );
        ; Setup parameters for call to function GAP_TerminateAuth
        MOV     R1,#0x5
        SJMP    ??CrossCallReturnLabel_36
//  924         }
//  925         else
//  926         {
//  927           linkDBItem_t *pLinkItem = linkDB_Find( pPkt->connectionHandle );
??GAPBondMgr_ProcessGAPMsg_21:
        ; Setup parameters for call to function linkDB_Find
        LCALL   ??linkDB_Find?relay
        MOV     ?V0 + 4,R2
        MOV     ?V0 + 5,R3
        MOV     R0,?V0 + 4
        MOV     R1,?V0 + 5
//  928 
//  929           // Requesting bonding?
//  930           if ( pPkt->pairReq.authReq & SM_AUTH_STATE_BONDING )
        MOV     A,R0
        ADD     A,#0x4
        MOV     ?V0 + 4,A
        MOV     A,R1
        ADDC    A,#0x0
        MOV     ?V0 + 5,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.0
        JNC     ??GAPBondMgr_ProcessGAPMsg_22
//  931           {
//  932             if ( pLinkItem )
        MOV     A,R0
        ORL     A,R1
        JZ      ??GAPBondMgr_ProcessGAPMsg_6
//  933             {
//  934               if ( (pLinkItem->addrType != ADDRTYPE_PUBLIC) && (pPkt->pairReq.keyDist.mIdKey == FALSE) )
        MOV     DPL,?V0 + 4
        MOV     DPH,?V0 + 5
        MOVX    A,@DPTR
        MOV     R6,A
        JZ      ??GAPBondMgr_ProcessGAPMsg_22
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        MOVX    A,@DPTR
        ANL     A,#0x10
        JNZ     ??GAPBondMgr_ProcessGAPMsg_22
//  935               {
//  936                 uint8 publicAddr[B_ADDR_LEN];
//  937 
//  938                 // Check if we already have the public address in NV
//  939                 if ( GAPBondMgr_ResolveAddr(pLinkItem->addrType, pLinkItem->addr, publicAddr ) == FALSE )
        ; Setup parameters for call to function GAPBondMgr_ResolveAddr
        MOV     A,#0xe
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     A,R0
        ADD     A,#0x5
        MOV     R2,A
        MOV     A,R1
        ADDC    A,#0x0
        MOV     R3,A
        MOV     A,R6
        MOV     R1,A
        LCALL   ??GAPBondMgr_ResolveAddr?relay
        MOV     A,R1
        JNZ     ??GAPBondMgr_ProcessGAPMsg_22
//  940                 {
//  941                   // Can't bond to a non-public address if we don't know the public address
//  942                   VOID GAP_TerminateAuth( pPkt->connectionHandle, SMP_PAIRING_FAILED_AUTH_REQ );
        ; Setup parameters for call to function GAP_TerminateAuth
        MOV     R1,#0x3
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
??GAPBondMgr_ProcessGAPMsg_8:
        LCALL   ??Subroutine23_0 & 0xFFFF
??CrossCallReturnLabel_36:
        LCALL   ??GAP_TerminateAuth?relay
//  943                   break;
        SJMP    ??GAPBondMgr_ProcessGAPMsg_6
//  944                 }
//  945               }
//  946             }
//  947             else
//  948             {
//  949               // Can't find the connection, ignore the message
//  950               break;
//  951             }
//  952           }
//  953 
//  954           // Send pairing response
//  955           gapBondMgrAuthenticate( pPkt->connectionHandle, pLinkItem->addrType, &(pPkt->pairReq) );
??GAPBondMgr_ProcessGAPMsg_22:
        ; Setup parameters for call to function gapBondMgrAuthenticate
        MOV     R4,?V0 + 6
        MOV     R5,?V0 + 7
        MOV     DPL,?V0 + 4
        MOV     DPH,?V0 + 5
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ?Subroutine7 & 0xFFFF
??CrossCallReturnLabel_45:
        LCALL   ??gapBondMgrAuthenticate?relay
//  956 
//  957           // Call app state callback
//  958           if ( pGapBondCB && pGapBondCB->pairStateCB )
        LCALL   ?Subroutine9 & 0xFFFF
??CrossCallReturnLabel_5:
        JZ      ??GAPBondMgr_ProcessGAPMsg_6
        LCALL   ?Subroutine8 & 0xFFFF
??CrossCallReturnLabel_1:
        JZ      ??GAPBondMgr_ProcessGAPMsg_6
//  959           {
//  960             pGapBondCB->pairStateCB( pPkt->connectionHandle, GAPBOND_PAIRING_STATE_STARTED, SUCCESS );
        ; Setup parameters for indirect call
        MOV     R4,#0x0
        MOV     R1,#0x0
//  961           }
//  962         }
//  963       }
??GAPBondMgr_ProcessGAPMsg_18:
        LCALL   ?Subroutine7 & 0xFFFF
??CrossCallReturnLabel_46:
        MOV     DPL,R6
        MOV     DPH,R7
??GAPBondMgr_ProcessGAPMsg_19:
        LCALL   ?CALL_IND
        SJMP    ??GAPBondMgr_ProcessGAPMsg_6
//  964       break;
//  965 #endif
//  966 
//  967 #if ( HOST_CONFIG & CENTRAL_CFG )
//  968     case GAP_SLAVE_REQUESTED_SECURITY_EVENT:
//  969       {
//  970         uint16 connHandle = ((gapSlaveSecurityReqEvent_t *)pMsg)->connectionHandle;
//  971         uint8 idx;
//  972         uint8 publicAddr[B_ADDR_LEN] = {0, 0, 0, 0, 0, 0};
//  973         linkDBItem_t *pLink = linkDB_Find( connHandle );
//  974 
//  975         // If link found and not already initiating security
//  976         if (pLink != NULL && gapBond_PairingMode != GAPBOND_PAIRING_MODE_INITIATE)
//  977         {
//  978           // If already bonded initiate encryption
//  979           idx = GAPBondMgr_ResolveAddr( pLink->addrType, pLink->addr, publicAddr );
//  980           if ( idx < GAP_BONDINGS_MAX )
//  981           {
//  982             gapBondMgrBondReq( connHandle, idx, gapBondMgrGetStateFlags( idx ),
//  983                                GAP_PROFILE_CENTRAL, TRUE );
//  984           }
//  985           // Else if no pairing allowed
//  986           else if ( gapBond_PairingMode == GAPBOND_PAIRING_MODE_NO_PAIRING )
//  987           {
//  988             // Send error
//  989             VOID GAP_TerminateAuth( connHandle, SMP_PAIRING_FAILED_NOT_SUPPORTED );
//  990           }
//  991           // Else if waiting for request
//  992           else if (gapBond_PairingMode == GAPBOND_PAIRING_MODE_WAIT_FOR_REQ)
//  993           {
//  994             // Initiate pairing
//  995             gapBondMgrAuthenticate( connHandle, pLink->addrType, NULL );
//  996           }
//  997         }
//  998       }
//  999       break;
// 1000 #endif
// 1001 
// 1002     case GAP_LINK_TERMINATED_EVENT:
// 1003       if ( GAP_NumActiveConnections() == 0 )
??GAPBondMgr_ProcessGAPMsg_0:
        ; Setup parameters for call to function GAP_NumActiveConnections
        LCALL   ??GAP_NumActiveConnections?relay
        MOV     A,R1
        JNZ     ??GAPBondMgr_ProcessGAPMsg_6
// 1004       {
// 1005         // Make sure Bond RAM Shadow is up-to-date
// 1006         gapBondMgrReadBonds();
        ; Setup parameters for call to function gapBondMgrReadBonds
        LCALL   ??gapBondMgrReadBonds?relay
// 1007       }
// 1008       break;
// 1009 
// 1010     default:
// 1011       break;
// 1012   }
// 1013 }
??GAPBondMgr_ProcessGAPMsg_6:
        MOV     A,#0x14
        LCALL   ?DEALLOC_XSTACK8
        MOV     R7,#0xe
        LJMP    ?BANKED_LEAVE_XDATA

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine11:
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        RET

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine9:
        MOV     DPTR,#pGapBondCB
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        RET

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine8:
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        MOV     R6,A
        MOV     A,R1
        MOV     R7,A
        MOV     A,R6
        ORL     A,R7
        RET
// 1014 
// 1015 /*********************************************************************
// 1016  * LOCAL FUNCTION PROTOTYPES
// 1017  */
// 1018 
// 1019 /*********************************************************************
// 1020  * @fn      gapBondMgrChangeState
// 1021  *
// 1022  * @brief   Change a state flag in the stateFlags field of the bond record.
// 1023  *
// 1024  * @param   idx - Bond NV index
// 1025  * @param   state - state flage to set or clear
// 1026  * @param   set - TRUE to set the flag, FALSE to clear the flag
// 1027  *
// 1028  * @return  TRUE if NV Record exists, FALSE if NV Record is empty
// 1029  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1030 static uint8 gapBondMgrChangeState( uint8 idx, uint16 state, uint8 set )
gapBondMgrChangeState:
        CODE
// 1031 {
        MOV     A,#-0xc
        LCALL   ?BANKED_ENTER_XDATA
        ; Saved register size: 12
        ; Auto size: 14
        MOV     A,#-0xe
        LCALL   ?ALLOC_XSTACK8
        MOV     A,R2
        MOV     R6,A
        MOV     ?V0 + 3,R4
// 1032   gapBondRec_t bondRec;   // Space to read a Bond record from NV
// 1033 
// 1034   // Look for public address that is used (not all 0xFF's)
// 1035   if ( (osal_snv_read( mainRecordNvID(idx), sizeof ( gapBondRec_t ), &bondRec ) == SUCCESS)
// 1036       && (osal_isbufset( bondRec.publicAddr, 0xFF, B_ADDR_LEN ) == FALSE) )
        MOV     B,#0x6
        MOV     A,R1
        MUL     AB
        ADD     A,#0x20
        MOV     ?V0 + 0,A
        ; Setup parameters for call to function osal_snv_read
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,#0xe
        MOV     R1,A
        LCALL   ??osal_snv_read?relay
        MOV     A,R1
        JNZ     ??gapBondMgrChangeState_0
        ; Setup parameters for call to function osal_isbufset
        MOV     R4,#0x6
        MOV     R1,#-0x1
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??osal_isbufset?relay
        MOV     A,R1
        JNZ     ??gapBondMgrChangeState_0
// 1037   {
// 1038     // Update the state of the bonded device.
// 1039     uint8 stateFlags = bondRec.stateFlags;
        MOV     A,#0xc
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?Subroutine11 & 0xFFFF
??CrossCallReturnLabel_14:
        MOV     A,R0
        MOV     ?V0 + 1,A
// 1040     if ( set )
        MOV     A,?V0 + 3
        JZ      ??gapBondMgrChangeState_1
// 1041     {
// 1042       stateFlags |= state;
        MOV     A,R6
        ORL     ?V0 + 1,A
        SJMP    ??gapBondMgrChangeState_2
// 1043     }
// 1044     else
// 1045     {
// 1046       stateFlags &= ~(state);
??gapBondMgrChangeState_1:
        MOV     A,R6
        CPL     A
        ANL     ?V0 + 1,A
// 1047     }
// 1048 
// 1049     if ( stateFlags != bondRec.stateFlags )
??gapBondMgrChangeState_2:
        MOV     DPL,?V0 + 1
        MOV     R2,DPL
        MOV     A,R0
        XRL     A,R2
        JNZ     ??gapBondMgrChangeState_3
        MOV     A,R1
??gapBondMgrChangeState_3:
        JZ      ??gapBondMgrChangeState_4
// 1050     {
// 1051       bondRec.stateFlags = stateFlags;
        MOV     A,#0xc
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        CLR     A
        LCALL   ?Subroutine15 & 0xFFFF
// 1052       VOID osal_snv_write( mainRecordNvID(idx), sizeof ( gapBondRec_t ), &bondRec );
// 1053     }
??CrossCallReturnLabel_24:
        MOV     R1,?V0 + 0
        LCALL   ??osal_snv_write?relay
// 1054     return ( TRUE );
??gapBondMgrChangeState_4:
        MOV     R1,#0x1
        SJMP    ??gapBondMgrChangeState_5
// 1055   }
// 1056   return ( FALSE );
??gapBondMgrChangeState_0:
        MOV     R1,#0x0
??gapBondMgrChangeState_5:
        LJMP    ?Subroutine0 & 0xFFFF
// 1057 }
// 1058 
// 1059 /*********************************************************************
// 1060  * @fn      gapBondMgrUpdateCharCfg
// 1061  *
// 1062  * @brief   Update the Characteristic Configuration of the bond record.
// 1063  *
// 1064  * @param   idx - Bond NV index
// 1065  * @param   attrHandle - attribute handle (0 means all handles)
// 1066  * @param   value - characteristic configuration value
// 1067  *
// 1068  * @return  TRUE if NV Record exists, FALSE if NV Record is empty
// 1069  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1070 static uint8 gapBondMgrUpdateCharCfg( uint8 idx, uint16 attrHandle, uint16 value )
gapBondMgrUpdateCharCfg:
        CODE
// 1071 {
        MOV     A,#-0xe
        LCALL   ?BANKED_ENTER_XDATA
        ; Saved register size: 14
        ; Auto size: 26
        MOV     A,#-0x1a
        LCALL   ?ALLOC_XSTACK8
        MOV     ?V0 + 2,R1
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     A,R4
        MOV     R6,A
        MOV     A,R5
        MOV     R7,A
// 1072   gapBondRec_t bondRec;   // Space to read a Bond record from NV
// 1073 
// 1074   // Look for public address that is used (not all 0xFF's)
// 1075   if ( ( osal_snv_read( mainRecordNvID(idx), sizeof ( gapBondRec_t ), &bondRec ) == SUCCESS )
// 1076        && ( osal_isbufset( bondRec.publicAddr, 0xFF, B_ADDR_LEN ) == FALSE ) )
        ; Setup parameters for call to function osal_snv_read
        MOV     A,#0xc
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,#0xe
        MOV     B,#0x6
        MOV     A,R1
        MUL     AB
        ADD     A,#0x20
        MOV     R1,A
        LCALL   ??osal_snv_read?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??gapBondMgrUpdateCharCfg_0 & 0xFFFF
        ; Setup parameters for call to function osal_isbufset
        MOV     R4,#0x6
        MOV     R1,#-0x1
        MOV     A,#0xc
        LCALL   ?XSTACK_DISP0_8
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??osal_isbufset?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??gapBondMgrUpdateCharCfg_0 & 0xFFFF
// 1077   {
// 1078     gapBondCharCfg_t charCfg[GAP_CHAR_CFG_MAX]; // Space to read a char cfg record from NV
// 1079 
// 1080     if ( osal_snv_read( gattCfgNvID(idx), sizeof ( charCfg ), charCfg ) == SUCCESS )
        MOV     A,#0x70
        ADD     A,?V0 + 2
        MOV     ?V0 + 3,A
        ; Setup parameters for call to function osal_snv_read
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,#0xc
        MOV     R1,A
        LCALL   ??osal_snv_read?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??gapBondMgrUpdateCharCfg_1 & 0xFFFF
// 1081     {
// 1082       uint8 update = FALSE;
// 1083 
// 1084       gapBondMgrInvertCharCfgItem( charCfg );
        ; Setup parameters for call to function gapBondMgrInvertCharCfgItem
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??gapBondMgrInvertCharCfgItem?relay
// 1085 
// 1086       if ( attrHandle == GATT_INVALID_HANDLE )
        MOV     A,?V0 + 0
        ORL     A,?V0 + 1
        JNZ     ??gapBondMgrUpdateCharCfg_2
// 1087       {
// 1088         if ( osal_isbufset( (uint8 *)charCfg, 0x00, sizeof ( charCfg ) ) == FALSE )
        ; Setup parameters for call to function osal_isbufset
        MOV     R4,#0xc
        MOV     R1,#0x0
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??osal_isbufset?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??gapBondMgrUpdateCharCfg_1 & 0xFFFF
// 1089         {
// 1090           // Clear all characteristic configuration for this device
// 1091           VOID osal_memset( (void *)charCfg, 0x00, sizeof ( charCfg ) );
        ; Setup parameters for call to function osal_memset
        MOV     R4,#0xc
        MOV     R5,#0x0
        MOV     R1,#0x0
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??osal_memset?relay
// 1092           update = TRUE;
        SJMP    ??gapBondMgrUpdateCharCfg_3
// 1093         }
// 1094       }
// 1095       else
// 1096       {
// 1097         gapBondCharCfg_t *pItem = gapBondMgrFindCharCfgItem( attrHandle, charCfg );
??gapBondMgrUpdateCharCfg_2:
        ; Setup parameters for call to function gapBondMgrFindCharCfgItem
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
        LCALL   ??gapBondMgrFindCharCfgItem?relay
        MOV     ?V0 + 4,R2
        MOV     ?V0 + 5,R3
        MOV     R0,?V0 + 4
        MOV     R1,?V0 + 5
// 1098         if ( pItem == NULL )
        MOV     A,R0
        ORL     A,R1
        JNZ     ??gapBondMgrUpdateCharCfg_4
// 1099         {
// 1100           // Must be a new item; ignore if the value is no operation (default)
// 1101           if ( ( value == GATT_CFG_NO_OPERATION ) ||
// 1102                ( ( pItem = gapBondMgrFindCharCfgItem( GATT_INVALID_HANDLE, charCfg ) ) == NULL ) )
        MOV     A,R6
        ORL     A,R7
        JZ      ??gapBondMgrUpdateCharCfg_0
        ; Setup parameters for call to function gapBondMgrFindCharCfgItem
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,#0x0
        MOV     R3,#0x0
        LCALL   ??gapBondMgrFindCharCfgItem?relay
        MOV     A,R2
        MOV     R0,A
        MOV     A,R3
        MOV     R1,A
        MOV     A,R2
        ORL     A,R3
        JZ      ??gapBondMgrUpdateCharCfg_0
// 1103           {
// 1104             return ( FALSE ); // No empty entry found
// 1105           }
// 1106 
// 1107           pItem->attrHandle = attrHandle;
        MOV     DPL,R0
        MOV     DPH,R1
        MOV     A,?V0 + 0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?V0 + 1
        MOVX    @DPTR,A
// 1108         }
// 1109 
// 1110         if ( pItem->value != value )
??gapBondMgrUpdateCharCfg_4:
        LCALL   ?Subroutine17 & 0xFFFF
??CrossCallReturnLabel_29:
        MOV     R2,A
        MOV     A,R6
        XRL     A,R2
        JNZ     ??gapBondMgrUpdateCharCfg_5
        MOV     A,R7
??gapBondMgrUpdateCharCfg_5:
        JZ      ??gapBondMgrUpdateCharCfg_1
// 1111         {
// 1112           // Update characteristic configuration
// 1113           pItem->value = (uint8)value;
        MOV     A,R6
        MOVX    @DPTR,A
// 1114           if ( value == GATT_CFG_NO_OPERATION )
        ORL     A,R7
        JNZ     ??gapBondMgrUpdateCharCfg_3
// 1115           {
// 1116             // Erease the item
// 1117             pItem->attrHandle = GATT_INVALID_HANDLE;
        MOV     DPL,R0
        MOV     DPH,R1
        CLR     A
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    @DPTR,A
// 1118           }
// 1119 
// 1120           update = TRUE;
// 1121         }
// 1122       }
// 1123 
// 1124       // Update the characteristic configuration of the bonded device.
// 1125       if ( update )
// 1126       {
// 1127         gapBondMgrInvertCharCfgItem( charCfg );
??gapBondMgrUpdateCharCfg_3:
        ; Setup parameters for call to function gapBondMgrInvertCharCfgItem
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??gapBondMgrInvertCharCfgItem?relay
// 1128         VOID osal_snv_write( gattCfgNvID(idx), sizeof( charCfg ), charCfg );
        ; Setup parameters for call to function osal_snv_write
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,#0xc
        MOV     R1,?V0 + 3
        LCALL   ??osal_snv_write?relay
// 1129       }
// 1130     }
// 1131 
// 1132     return ( TRUE );
??gapBondMgrUpdateCharCfg_1:
        MOV     R1,#0x1
        SJMP    ??gapBondMgrUpdateCharCfg_6
// 1133   }
// 1134 
// 1135   return ( FALSE );
??gapBondMgrUpdateCharCfg_0:
        MOV     R1,#0x0
??gapBondMgrUpdateCharCfg_6:
        MOV     A,#0x1a
        REQUIRE ?Subroutine2
        ; // Fall through to label ?Subroutine2
// 1136 }

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine2:
        LCALL   ?DEALLOC_XSTACK8
        REQUIRE ??Subroutine21_0
        ; // Fall through to label ??Subroutine21_0

        RSEG BANKED_CODE:CODE:NOROOT(0)
??Subroutine21_0:
        MOV     R7,#0x6
        LJMP    ?BANKED_LEAVE_XDATA
// 1137 
// 1138 /*********************************************************************
// 1139  * @fn      gapBondMgrFindCharCfgItem
// 1140  *
// 1141  * @brief   Find the Characteristic Configuration for a given attribute.
// 1142  *          Uses the attribute handle to search the charactersitic
// 1143  *          configuration table of a bonded device.
// 1144  *
// 1145  * @param   attrHandle - attribute handle.
// 1146  * @param   charCfgTbl - characteristic configuration table.
// 1147  *
// 1148  * @return  pointer to the found item. NULL, otherwise.
// 1149  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1150 static gapBondCharCfg_t *gapBondMgrFindCharCfgItem( uint16 attrHandle,
gapBondMgrFindCharCfgItem:
        CODE
// 1151                                                     gapBondCharCfg_t *charCfgTbl )
// 1152 {
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
        ; Saved register size: 9
        ; Auto size: 0
// 1153   for ( uint8 i = 0; i < GAP_CHAR_CFG_MAX; i++ )
        MOV     R7,#0x0
// 1154   {
// 1155     if ( charCfgTbl[i].attrHandle == attrHandle )
??gapBondMgrFindCharCfgItem_0:
        MOV     A,R7
        MOV     B,#0x3
        MUL     AB
        MOV     R0,A
        MOV     R1,B
        MOV     A,R4
        ADD     A,R0
        MOV     R0,A
        MOV     A,R5
        LCALL   ?Subroutine16 & 0xFFFF
??CrossCallReturnLabel_27:
        MOVX    A,@DPTR
        XRL     A,R2
        JNZ     ??gapBondMgrFindCharCfgItem_1
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,R3
??gapBondMgrFindCharCfgItem_1:
        JNZ     ??gapBondMgrFindCharCfgItem_2
// 1156     {
// 1157       return ( &(charCfgTbl[i]) );
        MOV     A,R0
        MOV     R2,A
        MOV     A,R1
        MOV     R3,A
        SJMP    ??gapBondMgrFindCharCfgItem_3
// 1158     }
// 1159   }
??gapBondMgrFindCharCfgItem_2:
        INC     R7
        MOV     A,R7
        CLR     C
        SUBB    A,#0x4
        JC      ??gapBondMgrFindCharCfgItem_0
// 1160 
// 1161   return ( (gapBondCharCfg_t *)NULL );
        MOV     R2,#0x0
        MOV     R3,#0x0
??gapBondMgrFindCharCfgItem_3:
        LJMP    ??Subroutine22_0 & 0xFFFF
// 1162 }

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine16:
        ADDC    A,R1
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        RET
// 1163 
// 1164 /*********************************************************************
// 1165  * @fn      gapBondMgrFindCharCfgItem
// 1166  *
// 1167  * @brief   Invert the Characteristic Configuration for a given client.
// 1168  *
// 1169  * @param   charCfgTbl - characteristic configuration table.
// 1170  *
// 1171  * @return  none.
// 1172  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1173 static void gapBondMgrInvertCharCfgItem( gapBondCharCfg_t *charCfgTbl )
gapBondMgrInvertCharCfgItem:
        CODE
// 1174 {
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
        ; Saved register size: 9
        ; Auto size: 0
// 1175   for ( uint8 i = 0; i < GAP_CHAR_CFG_MAX; i++ )
        MOV     R6,#0x0
// 1176   {
// 1177     charCfgTbl[i].attrHandle = ~(charCfgTbl[i].attrHandle);
??gapBondMgrInvertCharCfgItem_0:
        MOV     A,R6
        MOV     B,#0x3
        MUL     AB
        MOV     R0,A
        MOV     R1,B
        MOV     A,R2
        ADD     A,R0
        MOV     R0,A
        MOV     A,R3
        LCALL   ?Subroutine16 & 0xFFFF
??CrossCallReturnLabel_28:
        MOVX    A,@DPTR
        CPL     A
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        CPL     A
        MOV     R5,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOV     A,R4
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R5
        MOVX    @DPTR,A
// 1178     charCfgTbl[i].value = ~(charCfgTbl[i].value);
        LCALL   ?Subroutine17 & 0xFFFF
// 1179   }
??CrossCallReturnLabel_30:
        CPL     A
        MOVX    @DPTR,A
        INC     R6
        MOV     A,R6
        CLR     C
        SUBB    A,#0x4
        JC      ??gapBondMgrInvertCharCfgItem_0
// 1180 }
        LJMP    ??Subroutine22_0 & 0xFFFF

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine17:
        MOV     A,R0
        ADD     A,#0x2
        MOV     DPL,A
        MOV     A,R1
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        RET
// 1181 
// 1182 /*********************************************************************
// 1183  * @fn      gapBondMgrAddBond
// 1184  *
// 1185  * @brief   Save a bond from a GAP Auth Complete Event
// 1186  *
// 1187  * @param   pBondRec - basic bond record
// 1188  * @param   pLocalLTK - LTK used by this device during pairing
// 1189  * @param   pDevLTK - LTK used by the connected device during pairing
// 1190  * @param   pIRK - IRK used by the connected device during pairing
// 1191  * @param   pSRK - SRK used by the connected device during pairing
// 1192  * @param   signCounter - Sign counter used by the connected device during pairing
// 1193  *
// 1194  * @return  bond index
// 1195  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1196 static uint8 gapBondMgrAddBond( gapBondRec_t *pBondRec,
gapBondMgrAddBond:
        CODE
// 1197                                 gapBondLTK_t *pLocalLTK, gapBondLTK_t *pDevLTK,
// 1198                                 uint8 *pIRK, uint8 *pSRK, uint32 signCounter )
// 1199 {
        MOV     A,#-0xc
        LCALL   ?BANKED_ENTER_XDATA
        ; Saved register size: 12
        ; Auto size: 12
        MOV     A,#-0xc
        LCALL   ?ALLOC_XSTACK8
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
        MOV     ?V0 + 0,R4
        MOV     ?V0 + 1,R5
// 1200   uint8 idx;
// 1201 
// 1202   if ( pBondRec == NULL )
        MOV     A,R6
        ORL     A,R7
        JNZ     ??gapBondMgrAddBond_0
// 1203   {
// 1204     return ( GAP_BONDINGS_MAX );
        MOV     R1,#0xa
        LJMP    ??gapBondMgrAddBond_1 & 0xFFFF
// 1205   }
// 1206 
// 1207   // First see if we already have an existing bond for this device
// 1208   idx = gapBondMgrFindAddr( pBondRec->publicAddr );
??gapBondMgrAddBond_0:
        ; Setup parameters for call to function gapBondMgrFindAddr
        LCALL   ??gapBondMgrFindAddr?relay
        MOV     A,R1
        MOV     ?V0 + 2,A
// 1209   if ( idx >= GAP_BONDINGS_MAX )
        CLR     C
        SUBB    A,#0xa
        JC      ??gapBondMgrAddBond_2
// 1210   {
// 1211     idx = gapBondMgrFindEmpty();
        MOV     ?V0 + 3,#0x0
??gapBondMgrAddBond_3:
        ; Setup parameters for call to function osal_isbufset
        MOV     R4,#0x6
        MOV     R1,#-0x1
        MOV     A,?V0 + 3
        MOV     B,#0xe
        MUL     AB
        MOV     R2,A
        MOV     R3,B
        MOV     A,#bonds & 0xff
        ADD     A,R2
        MOV     R2,A
        MOV     A,#(bonds >> 8) & 0xff
        ADDC    A,R3
        MOV     R3,A
        LCALL   ??osal_isbufset?relay
        MOV     A,R1
        JNZ     $+5
        LJMP    ??gapBondMgrAddBond_4 & 0xFFFF
        MOV     ?V0 + 2,?V0 + 3
// 1212   }
// 1213 
// 1214   if ( idx < GAP_BONDINGS_MAX )
??gapBondMgrAddBond_2:
        MOV     A,?V0 + 2
        CLR     C
        SUBB    A,#0xa
        JC      $+5
        LJMP    ??gapBondMgrAddBond_5 & 0xFFFF
// 1215   {
// 1216 
// 1217     gapBondCharCfg_t charCfg[GAP_CHAR_CFG_MAX];
// 1218 
// 1219     // Save the main information
// 1220     VOID osal_snv_write( mainRecordNvID(idx), sizeof ( gapBondRec_t ), pBondRec );
        MOV     B,#0x6
        MOV     A,?V0 + 2
        MUL     AB
        MOV     ?V0 + 3,A
        ; Setup parameters for call to function osal_snv_write
        MOV     A,R6
        MOV     R4,A
        MOV     A,R7
        MOV     R5,A
        MOV     R2,#0xe
        MOV     A,#0x20
        ADD     A,?V0 + 3
        MOV     R1,A
        LCALL   ??osal_snv_write?relay
// 1221 
// 1222     // If available, save the LTK information
// 1223     if ( pLocalLTK )
        MOV     A,?V0 + 0
        ORL     A,?V0 + 1
        JZ      ??gapBondMgrAddBond_6
// 1224     {
// 1225       VOID osal_snv_write( localLTKNvID(idx), sizeof ( gapBondLTK_t ), pLocalLTK );
        ; Setup parameters for call to function osal_snv_write
        MOV     R4,?V0 + 0
        MOV     R5,?V0 + 1
        MOV     R2,#0x1b
        MOV     A,#0x21
        ADD     A,?V0 + 3
        MOV     R1,A
        LCALL   ??osal_snv_write?relay
??gapBondMgrAddBond_6:
        MOV     A,#0x18
        LCALL   ?XSTACK_DISP0_8
// 1226     }
        LCALL   ?Subroutine10 & 0xFFFF
// 1227 
// 1228 
// 1229     // If availabe, save the connected device's LTK information
// 1230     if ( pDevLTK )
??CrossCallReturnLabel_6:
        JZ      ??gapBondMgrAddBond_7
// 1231     {
// 1232       VOID osal_snv_write( devLTKNvID(idx), sizeof ( gapBondLTK_t ), pDevLTK );
        ; Setup parameters for call to function osal_snv_write
        MOV     R2,#0x1b
        MOV     A,#0x22
        ADD     A,?V0 + 3
        MOV     R1,A
        LCALL   ??osal_snv_write?relay
??gapBondMgrAddBond_7:
        MOV     A,#0x1a
        LCALL   ?XSTACK_DISP0_8
// 1233     }
        LCALL   ?Subroutine10 & 0xFFFF
// 1234 
// 1235     // If available, save the connected device's IRK
// 1236     if ( pIRK )
??CrossCallReturnLabel_7:
        JZ      ??gapBondMgrAddBond_8
// 1237     {
// 1238       VOID osal_snv_write( devIRKNvID(idx), KEYLEN, pIRK );
        ; Setup parameters for call to function osal_snv_write
        MOV     R2,#0x10
        MOV     A,#0x23
        ADD     A,?V0 + 3
        MOV     R1,A
        LCALL   ??osal_snv_write?relay
??gapBondMgrAddBond_8:
        MOV     A,#0x1c
        LCALL   ?XSTACK_DISP0_8
// 1239     }
        LCALL   ?Subroutine10 & 0xFFFF
// 1240 
// 1241     // If available, save the connected device's Signature information
// 1242     if ( pSRK )
??CrossCallReturnLabel_8:
        JZ      ??gapBondMgrAddBond_9
// 1243     {
// 1244       VOID osal_snv_write( devCSRKNvID(idx), KEYLEN, pSRK );
        ; Setup parameters for call to function osal_snv_write
        MOV     R2,#0x10
        MOV     A,#0x24
        ADD     A,?V0 + 3
        MOV     R1,A
        LCALL   ??osal_snv_write?relay
// 1245       VOID osal_snv_write( devSignCounterNvID(idx), sizeof ( uint32 ), &signCounter );
        ; Setup parameters for call to function osal_snv_write
        MOV     A,#0x1e
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,#0x4
        MOV     A,#0x25
        ADD     A,?V0 + 3
        MOV     R1,A
        LCALL   ??osal_snv_write?relay
// 1246     }
// 1247 
// 1248     // Write out FF's over the charactersitic configuration entry, to overwrite
// 1249     // any previous bond data that may have been stored
// 1250     VOID osal_memset( charCfg, 0xFF, sizeof ( charCfg ) );
??gapBondMgrAddBond_9:
        ; Setup parameters for call to function osal_memset
        MOV     R4,#0xc
        MOV     R5,#0x0
        MOV     R1,#-0x1
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??osal_memset?relay
// 1251 
// 1252     VOID osal_snv_write( gattCfgNvID(idx), sizeof ( charCfg ), charCfg );
        ; Setup parameters for call to function osal_snv_write
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,#0xc
        MOV     A,#0x70
        ADD     A,?V0 + 2
        MOV     R1,A
        LCALL   ??osal_snv_write?relay
// 1253 
// 1254     // Update Bond RAM Shadow just with the newly added bond entry
// 1255     VOID osal_memcpy( &(bonds[idx]), pBondRec, sizeof ( gapBondRec_t ) );
        ; Setup parameters for call to function osal_memcpy
        MOV     ?V0 + 0,#0xe
        MOV     ?V0 + 1,#0x0
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     A,R6
        MOV     R4,A
        MOV     A,R7
        MOV     R5,A
        MOV     A,?V0 + 2
        MOV     B,#0xe
        MUL     AB
        MOV     R0,A
        MOV     R1,B
        MOV     A,#bonds & 0xff
        ADD     A,R0
        MOV     R2,A
        MOV     A,#(bonds >> 8) & 0xff
        ADDC    A,R1
        MOV     R3,A
        LCALL   ??osal_memcpy?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
// 1256 
// 1257     if ( autoSyncWhiteList )
        MOV     DPTR,#autoSyncWhiteList
        MOVX    A,@DPTR
        JZ      ??gapBondMgrAddBond_10
// 1258     {
// 1259       gapBondMgr_SyncWhiteList();
        ; Setup parameters for call to function gapBondMgr_SyncWhiteList
        LCALL   ??gapBondMgr_SyncWhiteList?relay
// 1260     }
// 1261 
// 1262     // Update the GAP Privacy Flag Properties
// 1263     gapBondSetupPrivFlag();
??gapBondMgrAddBond_10:
        ; Setup parameters for call to function gapBondSetupPrivFlag
        LCALL   ??gapBondSetupPrivFlag?relay
// 1264   }
// 1265 
// 1266   return ( idx );
??gapBondMgrAddBond_5:
        MOV     R1,?V0 + 2
??gapBondMgrAddBond_1:
        MOV     A,#0xc
        LJMP    ??Subroutine19_0 & 0xFFFF
??gapBondMgrAddBond_4:
        INC     ?V0 + 3
        MOV     A,?V0 + 3
        CLR     C
        SUBB    A,#0xa
        JNC     $+5
        LJMP    ??gapBondMgrAddBond_3 & 0xFFFF
        MOV     ?V0 + 2,#0xa
        SJMP    ??gapBondMgrAddBond_5
// 1267 }

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine10:
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     A,R4
        ORL     A,R5
        RET
// 1268 
// 1269 /*********************************************************************
// 1270  * @fn      gapBondMgrGetStateFlags
// 1271  *
// 1272  * @brief   Gets the state flags field of a bond record in NV
// 1273  *
// 1274  * @param   idx
// 1275  *
// 1276  * @return  stateFlags field
// 1277  */
// 1278 static uint8 gapBondMgrGetStateFlags( uint8 idx )
// 1279 {
// 1280   gapBondRec_t bondRec;
// 1281 
// 1282   VOID osal_snv_read( mainRecordNvID(idx), sizeof ( gapBondRec_t ), &bondRec );
// 1283 
// 1284   return ( bondRec.stateFlags );
// 1285 
// 1286 }
// 1287 
// 1288 /*********************************************************************
// 1289  * @fn      gapBondMgrGetPublicAddr
// 1290  *
// 1291  * @brief   Copy the public Address from a bonding record
// 1292  *
// 1293  * @param   idx - Bond record index
// 1294  * @param   pAddr - a place to put the public address from NV
// 1295  *
// 1296  * @return  SUCCESS if successful.
// 1297  *          Otherwise failure.
// 1298  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1299 static bStatus_t gapBondMgrGetPublicAddr( uint8 idx, uint8 *pAddr )
gapBondMgrGetPublicAddr:
        CODE
// 1300 {
        MOV     A,#-0xc
        LCALL   ?BANKED_ENTER_XDATA
        ; Saved register size: 12
        ; Auto size: 14
        MOV     A,#-0xe
        LCALL   ?ALLOC_XSTACK8
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
// 1301   bStatus_t stat;         // return value
// 1302   gapBondRec_t bondRec;   // Work space for main bond record
// 1303 
// 1304   // Check parameters
// 1305   if ( (idx >= GAP_BONDINGS_MAX) || (pAddr == NULL) )
        MOV     A,R1
        CLR     C
        SUBB    A,#0xa
        JNC     ??gapBondMgrGetPublicAddr_0
        MOV     A,R6
        ORL     A,R7
        JNZ     ??gapBondMgrGetPublicAddr_1
// 1306   {
// 1307     return ( INVALIDPARAMETER );
??gapBondMgrGetPublicAddr_0:
        MOV     R1,#0x2
        SJMP    ??gapBondMgrGetPublicAddr_2
// 1308   }
// 1309 
// 1310   stat = osal_snv_read( mainRecordNvID(idx), sizeof ( gapBondRec_t ), &bondRec );
??gapBondMgrGetPublicAddr_1:
        ; Setup parameters for call to function osal_snv_read
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,#0xe
        MOV     B,#0x6
        MOV     A,R1
        MUL     AB
        ADD     A,#0x20
        MOV     R1,A
        LCALL   ??osal_snv_read?relay
        MOV     A,R1
        MOV     ?V0 + 0,A
// 1311 
// 1312   if ( stat == SUCCESS )
        JNZ     ??gapBondMgrGetPublicAddr_3
// 1313   {
// 1314     VOID osal_memcpy( pAddr, bondRec.publicAddr, B_ADDR_LEN );
        ; Setup parameters for call to function osal_memcpy
        MOV     ?V0 + 2,#0x6
        MOV     ?V0 + 3,#0x0
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   ??osal_memcpy?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
// 1315   }
// 1316 
// 1317   return ( stat );
??gapBondMgrGetPublicAddr_3:
        MOV     R1,?V0 + 0
??gapBondMgrGetPublicAddr_2:
        LJMP    ?Subroutine0 & 0xFFFF
// 1318 }
// 1319 
// 1320 /*********************************************************************
// 1321  * @fn      gapBondMgrFindReconnectAddr
// 1322  *
// 1323  * @brief   Look through the bonding entries to find a
// 1324  *          reconnection address.
// 1325  *
// 1326  * @param   pReconnectAddr - device address to look for
// 1327  *
// 1328  * @return  index to found bonding (0 - (GAP_BONDINGS_MAX-1),
// 1329  *          GAP_BONDINGS_MAX if no empty entries
// 1330  */
// 1331 static uint8 gapBondMgrFindReconnectAddr( uint8 *pReconnectAddr )
// 1332 {
// 1333   // Item doesn't exist, so create all the items
// 1334   for ( uint8 idx = 0; idx < GAP_BONDINGS_MAX; idx++ )
// 1335   {
// 1336     // compare reconnection address
// 1337     if ( osal_memcmp( bonds[idx].reconnectAddr, pReconnectAddr, B_ADDR_LEN ) )
// 1338     {
// 1339       return ( idx ); // Found it
// 1340     }
// 1341   }
// 1342 
// 1343   return ( GAP_BONDINGS_MAX );
// 1344 }
// 1345 
// 1346 /*********************************************************************
// 1347  * @fn      gapBondMgrFindAddr
// 1348  *
// 1349  * @brief   Look through the bonding entries to find an address.
// 1350  *
// 1351  * @param   pDevAddr - device address to look for
// 1352  *
// 1353  * @return  index to empty bonding (0 - (GAP_BONDINGS_MAX-1),
// 1354  *          GAP_BONDINGS_MAX if no empty entries
// 1355  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1356 static uint8 gapBondMgrFindAddr( uint8 *pDevAddr )
gapBondMgrFindAddr:
        CODE
// 1357 {
        MOV     A,#-0xc
        LCALL   ?BANKED_ENTER_XDATA
        ; Saved register size: 12
        ; Auto size: 0
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
// 1358   // Item doesn't exist, so create all the items
// 1359   for ( uint8 idx = 0; idx < GAP_BONDINGS_MAX; idx++ )
        MOV     ?V0 + 0,#0x0
// 1360   {
// 1361     // Read in NV Main Bond Record and compare public address
// 1362     if ( osal_memcmp( bonds[idx].publicAddr, pDevAddr, B_ADDR_LEN ) )
??gapBondMgrFindAddr_0:
        ; Setup parameters for call to function osal_memcmp
        MOV     ?V0 + 2,#0x6
        MOV     ?V0 + 3,#0x0
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     A,R6
        MOV     R4,A
        MOV     A,R7
        MOV     R5,A
        MOV     A,?V0 + 0
        MOV     B,#0xe
        MUL     AB
        MOV     R0,A
        MOV     R1,B
        MOV     A,#bonds & 0xff
        ADD     A,R0
        MOV     R2,A
        MOV     A,#(bonds >> 8) & 0xff
        ADDC    A,R1
        MOV     R3,A
        LCALL   ??osal_memcmp?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        MOV     A,R1
        JZ      ??gapBondMgrFindAddr_1
// 1363     {
// 1364       return ( idx ); // Found it
        MOV     R1,?V0 + 0
        SJMP    ??gapBondMgrFindAddr_2
// 1365     }
// 1366   }
??gapBondMgrFindAddr_1:
        INC     ?V0 + 0
        MOV     A,?V0 + 0
        CLR     C
        SUBB    A,#0xa
        JC      ??gapBondMgrFindAddr_0
// 1367 
// 1368   return ( GAP_BONDINGS_MAX );
        MOV     R1,#0xa
??gapBondMgrFindAddr_2:
        LJMP    ??Subroutine20_0 & 0xFFFF
// 1369 }
// 1370 
// 1371 /*********************************************************************
// 1372  * @fn      gapBondMgrResolvePrivateAddr
// 1373  *
// 1374  * @brief   Look through the NV bonding entries to resolve a private
// 1375  *          address.
// 1376  *
// 1377  * @param   pDevAddr - device address to look for
// 1378  *
// 1379  * @return  index to found bonding (0 - (GAP_BONDINGS_MAX-1),
// 1380  *          GAP_BONDINGS_MAX if no entry found
// 1381  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1382 static uint8 gapBondMgrResolvePrivateAddr( uint8 *pDevAddr )
gapBondMgrResolvePrivateAddr:
        CODE
// 1383 {
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
        ; Saved register size: 9
        ; Auto size: 16
        MOV     A,#-0x10
        LCALL   ?ALLOC_XSTACK8
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
// 1384   for ( uint8 idx = 0; idx < GAP_BONDINGS_MAX; idx++ )
        MOV     ?V0 + 0,#0x0
// 1385   {
// 1386     uint8 IRK[KEYLEN];
// 1387 
// 1388     // Read in NV IRK Record and compare resovable address
// 1389     VOID osal_snv_read( devIRKNvID(idx), KEYLEN, IRK );
??gapBondMgrResolvePrivateAddr_0:
        ; Setup parameters for call to function osal_snv_read
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,#0x10
        MOV     B,#0x6
        MOV     A,?V0 + 0
        MUL     AB
        ADD     A,#0x23
        MOV     R1,A
        LCALL   ??osal_snv_read?relay
// 1390 
// 1391     if ( ( osal_isbufset( IRK, 0xFF, KEYLEN ) == FALSE ) &&
// 1392          ( GAP_ResolvePrivateAddr( IRK, pDevAddr ) == SUCCESS ) )
        ; Setup parameters for call to function osal_isbufset
        MOV     R4,#0x10
        MOV     R1,#-0x1
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??osal_isbufset?relay
        MOV     A,R1
        JNZ     ??gapBondMgrResolvePrivateAddr_1
        ; Setup parameters for call to function GAP_ResolvePrivateAddr
        MOV     A,R6
        MOV     R4,A
        MOV     A,R7
        MOV     R5,A
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??GAP_ResolvePrivateAddr?relay
        MOV     A,R1
        JNZ     ??gapBondMgrResolvePrivateAddr_1
// 1393     {
// 1394       return ( idx ); // Found it
        MOV     R1,?V0 + 0
        SJMP    ??gapBondMgrResolvePrivateAddr_2
// 1395     }
// 1396   }
??gapBondMgrResolvePrivateAddr_1:
        INC     ?V0 + 0
        MOV     A,?V0 + 0
        CLR     C
        SUBB    A,#0xa
        JC      ??gapBondMgrResolvePrivateAddr_0
// 1397 
// 1398   return ( GAP_BONDINGS_MAX );
        MOV     R1,#0xa
??gapBondMgrResolvePrivateAddr_2:
        MOV     A,#0x10
        SJMP    ?Subroutine4
// 1399 }
// 1400 
// 1401 /*********************************************************************
// 1402  * @fn      gapBondMgrReadBonds
// 1403  *
// 1404  * @brief   Read through NV and store them in RAM.
// 1405  *
// 1406  * @param   none
// 1407  *
// 1408  * @return  none
// 1409  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1410 static void gapBondMgrReadBonds( void )
gapBondMgrReadBonds:
        CODE
// 1411 {
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
        ; Saved register size: 9
        ; Auto size: 0
// 1412   VOID osal_memset( bonds, 0, (sizeof ( gapBondRec_t ) * GAP_BONDINGS_MAX) );
        ; Setup parameters for call to function osal_memset
        MOV     R4,#-0x74
        MOV     R5,#0x0
        MOV     R1,#0x0
        MOV     R2,#bonds & 0xff
        MOV     R3,#(bonds >> 8) & 0xff
        LCALL   ??osal_memset?relay
// 1413 
// 1414   for ( uint8 idx = 0; idx < GAP_BONDINGS_MAX; idx++ )
        MOV     R6,#0x0
// 1415   {
// 1416     // Read in NV Main Bond Record and compare public address
// 1417     VOID osal_snv_read( mainRecordNvID(idx), sizeof ( gapBondRec_t ), &(bonds[idx]) );
??gapBondMgrReadBonds_0:
        ; Setup parameters for call to function osal_snv_read
        MOV     A,R6
        MOV     B,#0xe
        MUL     AB
        MOV     R0,A
        MOV     R1,B
        MOV     A,#bonds & 0xff
        ADD     A,R0
        MOV     R4,A
        MOV     A,#(bonds >> 8) & 0xff
        ADDC    A,R1
        MOV     R5,A
        MOV     R2,#0xe
        MOV     B,#0x6
        MOV     A,R6
        MUL     AB
        ADD     A,#0x20
        MOV     R1,A
        LCALL   ??osal_snv_read?relay
// 1418   }
        INC     R6
        MOV     A,R6
        CLR     C
        SUBB    A,#0xa
        JC      ??gapBondMgrReadBonds_0
// 1419 
// 1420   if ( autoSyncWhiteList )
        MOV     DPTR,#autoSyncWhiteList
        MOVX    A,@DPTR
        JZ      ??gapBondMgrReadBonds_1
// 1421   {
// 1422     gapBondMgr_SyncWhiteList();
        ; Setup parameters for call to function gapBondMgr_SyncWhiteList
        LCALL   ??gapBondMgr_SyncWhiteList?relay
// 1423   }
// 1424 
// 1425   // Update the GAP Privacy Flag Properties
// 1426   gapBondSetupPrivFlag();
??gapBondMgrReadBonds_1:
        ; Setup parameters for call to function gapBondSetupPrivFlag
        LCALL   ??gapBondSetupPrivFlag?relay
// 1427 }
        SJMP    ??Subroutine22_0

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine4:
        LCALL   ?DEALLOC_XSTACK8
        REQUIRE ??Subroutine22_0
        ; // Fall through to label ??Subroutine22_0

        RSEG BANKED_CODE:CODE:NOROOT(0)
??Subroutine22_0:
        MOV     R7,#0x1
        LJMP    ?BANKED_LEAVE_XDATA
// 1428 
// 1429 /*********************************************************************
// 1430  * @fn      gapBondMgrFindEmpty
// 1431  *
// 1432  * @brief   Look through the bonding NV entries to find an empty.
// 1433  *
// 1434  * @param   none
// 1435  *
// 1436  * @return  index to empty bonding (0 - (GAP_BONDINGS_MAX-1),
// 1437  *          GAP_BONDINGS_MAX if no empty entries
// 1438  */
// 1439 static uint8 gapBondMgrFindEmpty( void )
// 1440 {
// 1441   // Item doesn't exist, so create all the items
// 1442   for ( uint8 idx = 0; idx < GAP_BONDINGS_MAX; idx++ )
// 1443   {
// 1444     // Look for public address of all 0xFF's
// 1445     if ( osal_isbufset( bonds[idx].publicAddr, 0xFF, B_ADDR_LEN ) )
// 1446     {
// 1447       return ( idx ); // Found one
// 1448     }
// 1449   }
// 1450 
// 1451   return ( GAP_BONDINGS_MAX );
// 1452 }
// 1453 
// 1454 /*********************************************************************
// 1455  * @fn      gapBondMgrBondTotal
// 1456  *
// 1457  * @brief   Look through the bonding NV entries calculate the number
// 1458  *          entries.
// 1459  *
// 1460  * @param   none
// 1461  *
// 1462  * @return  total number of bonds found
// 1463  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1464 static uint8 gapBondMgrBondTotal( void )
gapBondMgrBondTotal:
        CODE
// 1465 {
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
        ; Saved register size: 9
        ; Auto size: 0
// 1466   uint8 numBonds = 0;
        MOV     R6,#0x0
// 1467 
// 1468   // Item doesn't exist, so create all the items
// 1469   for ( uint8 idx = 0; idx < GAP_BONDINGS_MAX; idx++ )
        MOV     R7,#0x0
// 1470   {
// 1471     // Look for public address that are not 0xFF's
// 1472     if ( osal_isbufset( bonds[idx].publicAddr, 0xFF, B_ADDR_LEN ) == FALSE )
??gapBondMgrBondTotal_0:
        ; Setup parameters for call to function osal_isbufset
        MOV     R4,#0x6
        MOV     R1,#-0x1
        MOV     A,R7
        MOV     B,#0xe
        MUL     AB
        MOV     R2,A
        MOV     R3,B
        MOV     A,#bonds & 0xff
        ADD     A,R2
        MOV     R2,A
        MOV     A,#(bonds >> 8) & 0xff
        ADDC    A,R3
        MOV     R3,A
        LCALL   ??osal_isbufset?relay
        MOV     A,R1
        JNZ     ??gapBondMgrBondTotal_1
// 1473     {
// 1474       numBonds++; // Found one
        INC     R6
// 1475     }
// 1476   }
??gapBondMgrBondTotal_1:
        INC     R7
        MOV     A,R7
        CLR     C
        SUBB    A,#0xa
        JC      ??gapBondMgrBondTotal_0
// 1477 
// 1478   return ( numBonds );
        MOV     A,R6
        MOV     R1,A
        SJMP    ??Subroutine22_0
// 1479 }
// 1480 
// 1481 /*********************************************************************
// 1482  * @fn      gapBondMgrEraseAllBondings
// 1483  *
// 1484  * @brief   Write all 0xFF's to all of the bonding entries
// 1485  *
// 1486  * @param   none
// 1487  *
// 1488  * @return  SUCCESS if successful.
// 1489  *          Otherwise, NV_OPER_FAILED for failure.
// 1490  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1491 static bStatus_t gapBondMgrEraseAllBondings( void )
gapBondMgrEraseAllBondings:
        CODE
// 1492 {
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
        ; Saved register size: 9
        ; Auto size: 0
// 1493   bStatus_t stat = SUCCESS;  // return value
// 1494 
// 1495   // Item doesn't exist, so create all the items
// 1496   for ( uint8 idx = 0; (idx < GAP_BONDINGS_MAX) && (stat == SUCCESS); idx++ )
        MOV     R6,#0x0
// 1497   {
// 1498     // Erasing will write/create a bonding entry
// 1499     stat = gapBondMgrEraseBonding( idx );
??gapBondMgrEraseAllBondings_0:
        ; Setup parameters for call to function gapBondMgrEraseBonding
        MOV     A,R6
        MOV     R1,A
        LCALL   ??gapBondMgrEraseBonding?relay
// 1500   }
        INC     R6
        MOV     A,R6
        CLR     C
        SUBB    A,#0xa
        JNC     ??gapBondMgrEraseAllBondings_1
        MOV     A,R1
        JZ      ??gapBondMgrEraseAllBondings_0
// 1501 
// 1502   return ( stat );
??gapBondMgrEraseAllBondings_1:
        SJMP    ??Subroutine22_0
// 1503 }
// 1504 
// 1505 /*********************************************************************
// 1506  * @fn      gapBondMgrEraseBonding
// 1507  *
// 1508  * @brief   Write all 0xFF's to the complete bonding record
// 1509  *
// 1510  * @param   idx - bonding index
// 1511  *
// 1512  * @return  SUCCESS if successful.
// 1513  *          Otherwise, NV_OPER_FAILED for failure.
// 1514  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1515 static bStatus_t gapBondMgrEraseBonding( uint8 idx )
gapBondMgrEraseBonding:
        CODE
// 1516 {
        MOV     A,#-0xd
        LCALL   ?BANKED_ENTER_XDATA
        ; Saved register size: 13
        ; Auto size: 53
        MOV     A,#-0x35
        LCALL   ?ALLOC_XSTACK8
        MOV     A,R1
        MOV     R6,A
// 1517   bStatus_t ret;
// 1518   gapBondRec_t bondRec;
// 1519   gapBondLTK_t ltk;
// 1520   gapBondCharCfg_t charCfg[GAP_CHAR_CFG_MAX];
// 1521 
// 1522   VOID osal_memset( &bondRec, 0xFF, sizeof ( gapBondRec_t ) );
        ; Setup parameters for call to function osal_memset
        MOV     R4,#0xe
        MOV     R5,#0x0
        MOV     R1,#-0x1
        MOV     A,#0x27
        LCALL   ?XSTACK_DISP0_8
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??osal_memset?relay
// 1523   VOID osal_memset( &ltk, 0xFF, sizeof ( gapBondLTK_t ) );
        ; Setup parameters for call to function osal_memset
        MOV     R4,#0x1b
        MOV     R5,#0x0
        MOV     R1,#-0x1
        MOV     A,#0xc
        LCALL   ?XSTACK_DISP0_8
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??osal_memset?relay
// 1524 
// 1525   VOID osal_memset( charCfg, 0xFF, sizeof ( charCfg ) );
        ; Setup parameters for call to function osal_memset
        MOV     R4,#0xc
        MOV     R5,#0x0
        MOV     R1,#-0x1
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??osal_memset?relay
// 1526 
// 1527   // Write out FF's over the entire bond entry.
// 1528   ret = osal_snv_write( mainRecordNvID(idx), sizeof ( gapBondRec_t ), &bondRec );
        MOV     B,#0x6
        MOV     A,R6
        MUL     AB
        MOV     R7,A
        ; Setup parameters for call to function osal_snv_write
        MOV     A,#0x27
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,#0xe
        MOV     A,#0x20
        ADD     A,R7
        MOV     R1,A
        LCALL   ??osal_snv_write?relay
        MOV     A,R1
        MOV     ?V0 + 0,A
// 1529   ret |= osal_snv_write( localLTKNvID(idx), sizeof ( gapBondLTK_t ), &ltk );
        ; Setup parameters for call to function osal_snv_write
        MOV     A,#0xc
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,#0x1b
        MOV     A,#0x21
        ADD     A,R7
        MOV     R1,A
        LCALL   ??osal_snv_write?relay
        MOV     A,R1
        MOV     ?V0 + 1,A
// 1530   ret |= osal_snv_write( devLTKNvID(idx), sizeof ( gapBondLTK_t ), &ltk );
        ; Setup parameters for call to function osal_snv_write
        MOV     A,#0xc
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,#0x1b
        MOV     A,#0x22
        ADD     A,R7
        MOV     R1,A
        LCALL   ??osal_snv_write?relay
        MOV     A,R1
        MOV     ?V0 + 2,A
// 1531   ret |= osal_snv_write( devIRKNvID(idx), KEYLEN, ltk.LTK );
        ; Setup parameters for call to function osal_snv_write
        MOV     A,#0xc
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,#0x10
        MOV     A,#0x23
        ADD     A,R7
        MOV     R1,A
        LCALL   ??osal_snv_write?relay
        MOV     A,R1
        MOV     ?V0 + 3,A
// 1532   ret |= osal_snv_write( devCSRKNvID(idx), KEYLEN, ltk.LTK );
        ; Setup parameters for call to function osal_snv_write
        MOV     A,#0xc
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,#0x10
        MOV     A,#0x24
        ADD     A,R7
        MOV     R1,A
        LCALL   ??osal_snv_write?relay
        MOV     A,R1
        MOV     ?V0 + 4,A
// 1533   ret |= osal_snv_write( devSignCounterNvID(idx), sizeof ( uint32 ), ltk.LTK );
        ; Setup parameters for call to function osal_snv_write
        MOV     A,#0xc
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,#0x4
        MOV     A,#0x25
        ADD     A,R7
        MOV     R1,A
        LCALL   ??osal_snv_write?relay
        MOV     A,R1
        MOV     R7,A
// 1534 
// 1535   // Write out FF's over the charactersitic configuration entry.
// 1536   ret |= osal_snv_write( gattCfgNvID(idx), sizeof ( charCfg ), charCfg );
// 1537 
// 1538   return ( ret );
        ; Setup parameters for call to function osal_snv_write
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,#0xc
        MOV     A,#0x70
        ADD     A,R6
        MOV     R1,A
        LCALL   ??osal_snv_write?relay
        MOV     A,R1
        MOV     R0,A
        MOV     A,?V0 + 0
        ORL     A,?V0 + 1
        ORL     A,?V0 + 2
        ORL     A,?V0 + 3
        ORL     A,?V0 + 4
        ORL     A,R7
        ORL     A,R0
        MOV     R1,A
        MOV     A,#0x35
        REQUIRE ?Subroutine5
        ; // Fall through to label ?Subroutine5
// 1539 }

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine5:
        LCALL   ?DEALLOC_XSTACK8
        MOV     R7,#0x5
        LJMP    ?BANKED_LEAVE_XDATA
// 1540 
// 1541 /*********************************************************************
// 1542  * @brief   Task Initialization function.
// 1543  *
// 1544  * Internal function defined in gapbondmgr.h.
// 1545  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1546 void GAPBondMgr_Init( uint8 task_id )
GAPBondMgr_Init:
        CODE
// 1547 {
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
        ; Saved register size: 9
        ; Auto size: 14
        MOV     A,#-0xe
        LCALL   ?ALLOC_XSTACK8
        MOV     A,R1
// 1548   gapBondRec_t bondRec;         // Work space for Bond Record
// 1549   gapBondMgr_TaskID = task_id;  // Save task ID
        MOV     DPTR,#gapBondMgr_TaskID
        LCALL   ?Subroutine15 & 0xFFFF
// 1550 
// 1551   // Initialize the NV needed for bonding
// 1552   if ( osal_snv_read( mainRecordNvID(0), sizeof ( gapBondRec_t ), &bondRec ) != SUCCESS )
??CrossCallReturnLabel_25:
        MOV     R1,#0x20
        LCALL   ??osal_snv_read?relay
        MOV     A,R1
        JZ      ??GAPBondMgr_Init_0
// 1553   {
// 1554     // Can't read the first entry, assume that NV doesn't exist and erase all
// 1555     // Bond NV entries (initialize)
// 1556     VOID gapBondMgrEraseAllBondings();
        ; Setup parameters for call to function gapBondMgrEraseAllBondings
        LCALL   ??gapBondMgrEraseAllBondings?relay
// 1557   }
// 1558 
// 1559   // Since bond manager is using NV, NV usage must be declared to controller
// 1560   VOID HCI_EXT_DeclareNvUsageCmd( HCI_EXT_NV_IN_USE );
??GAPBondMgr_Init_0:
        ; Setup parameters for call to function HCI_EXT_DeclareNvUsageCmd
        MOV     R1,#0x1
        LCALL   ??HCI_EXT_DeclareNvUsageCmd?relay
// 1561 
// 1562   // Setup Bond RAM Shadow
// 1563   gapBondMgrReadBonds();
        ; Setup parameters for call to function gapBondMgrReadBonds
        LCALL   ??gapBondMgrReadBonds?relay
// 1564 }
        MOV     A,#0xe
        LJMP    ?Subroutine4 & 0xFFFF

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine15:
        MOVX    @DPTR,A
        ; Setup parameters for call to function osal_snv_write
        ; Setup parameters for call to function osal_snv_read
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,#0xe
        RET
// 1565 
// 1566 /*********************************************************************
// 1567  * @brief   Task Event Processor function.
// 1568  *
// 1569  * Internal function defined in gapbondmgr.h.
// 1570  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1571 uint16 GAPBondMgr_ProcessEvent( uint8 task_id, uint16 events )
GAPBondMgr_ProcessEvent:
        CODE
// 1572 {
        MOV     A,#-0xc
        LCALL   ?BANKED_ENTER_XDATA
        ; Saved register size: 12
        ; Auto size: 0
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
// 1573   VOID task_id; // OSAL required parameter that isn't used in this function
// 1574 
// 1575   if ( events & SYS_EVENT_MSG )
        MOV     A,R3
        ANL     A,#0x80
        JNZ     $+5
        LJMP    ??GAPBondMgr_ProcessEvent_0 & 0xFFFF
// 1576   {
// 1577     uint8 *pMsg;
// 1578 
// 1579     if ( (pMsg = osal_msg_receive( gapBondMgr_TaskID )) != NULL )
        ; Setup parameters for call to function osal_msg_receive
        MOV     DPTR,#gapBondMgr_TaskID
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??osal_msg_receive?relay
        MOV     ?V0 + 2,R2
        MOV     ?V0 + 3,R3
        MOV     R6,?V0 + 2
        MOV     R7,?V0 + 3
        MOV     A,R6
        ORL     A,R7
        JZ      ??GAPBondMgr_ProcessEvent_1
// 1580     {
// 1581       gapBondMgr_ProcessOSALMsg( (osal_event_hdr_t *)pMsg );
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        ADD     A,#0x50
        JZ      ??GAPBondMgr_ProcessEvent_2
        DEC     A
        JZ      ??GAPBondMgr_ProcessEvent_3
        ADD     A,#-0x1f
        JZ      ??GAPBondMgr_ProcessEvent_4
        SJMP    ??GAPBondMgr_ProcessEvent_5
??GAPBondMgr_ProcessEvent_3:
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        JNZ     ??GAPBondMgr_ProcessEvent_5
        ; Setup parameters for call to function GAPBondMgr_UpdateCharCfg
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        LCALL   ?PUSH_XSTACK8_X_TWO
        MOV     DPL,R6
        MOV     DPH,R7
        LCALL   ?Subroutine12 & 0xFFFF
??CrossCallReturnLabel_51:
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        LCALL   ??Subroutine23_0 & 0xFFFF
??CrossCallReturnLabel_37:
        LCALL   ??GAPBondMgr_UpdateCharCfg?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        SJMP    ??GAPBondMgr_ProcessEvent_5
??GAPBondMgr_ProcessEvent_2:
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#0x1e
        JNZ     ??GAPBondMgr_ProcessEvent_5
        ; Setup parameters for call to function GAPBondMgr_ServiceChangeInd
        MOV     R1,#0x0
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        LCALL   ??Subroutine23_0 & 0xFFFF
??CrossCallReturnLabel_38:
        LCALL   ??GAPBondMgr_ServiceChangeInd?relay
        SJMP    ??GAPBondMgr_ProcessEvent_5
??GAPBondMgr_ProcessEvent_4:
        ; Setup parameters for call to function GAPBondMgr_ProcessGAPMsg
        LCALL   ??GAPBondMgr_ProcessGAPMsg?relay
// 1582 
// 1583       // Release the OSAL message
// 1584       VOID osal_msg_deallocate( pMsg );
??GAPBondMgr_ProcessEvent_5:
        ; Setup parameters for call to function osal_msg_deallocate
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   ??osal_msg_deallocate?relay
// 1585     }
// 1586 
// 1587     // return unprocessed events
// 1588     return (events ^ SYS_EVENT_MSG);
??GAPBondMgr_ProcessEvent_1:
        MOV     R2,?V0 + 0
        MOV     A,?V0 + 1
        XRL     A,#0x80
        MOV     R3,A
        SJMP    ??GAPBondMgr_ProcessEvent_6
// 1589   }
// 1590 
// 1591   // Discard unknown events
// 1592   return 0;
??GAPBondMgr_ProcessEvent_0:
        MOV     R2,#0x0
        MOV     R3,#0x0
??GAPBondMgr_ProcessEvent_6:
        LJMP    ??Subroutine20_0 & 0xFFFF
// 1593 }

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine7:
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        REQUIRE ??Subroutine23_0
        ; // Fall through to label ??Subroutine23_0

        RSEG BANKED_CODE:CODE:NOROOT(0)
??Subroutine23_0:
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        RET
// 1594 
// 1595 /*********************************************************************
// 1596  * @fn      gapBondMgr_ProcessOSALMsg
// 1597  *
// 1598  * @brief   Process an incoming task message.
// 1599  *
// 1600  * @param   pMsg - message to process
// 1601  *
// 1602  * @return  none
// 1603  */
// 1604 static void gapBondMgr_ProcessOSALMsg( osal_event_hdr_t *pMsg )
// 1605 {
// 1606   switch ( pMsg->event )
// 1607   {
// 1608     case GAP_MSG_EVENT:
// 1609       GAPBondMgr_ProcessGAPMsg( (gapEventHdr_t *)pMsg );
// 1610       break;
// 1611 
// 1612     case GATT_MSG_EVENT:
// 1613       gapBondMgr_ProcessGATTMsg( (gattMsgEvent_t *)pMsg );
// 1614       break;
// 1615 
// 1616     case GATT_SERV_MSG_EVENT:
// 1617       gapBondMgr_ProcessGATTServMsg( (gattEventHdr_t *)pMsg );
// 1618       break;
// 1619 
// 1620     default:
// 1621       break;
// 1622   }
// 1623 }
// 1624 
// 1625 /*********************************************************************
// 1626  * @fn      GAPBondMgr_CheckNVLen
// 1627  *
// 1628  * @brief   This function will check the length of an NV Item.
// 1629  *
// 1630  * @param   id - NV ID.
// 1631  * @param   len - lengths in bytes of item.
// 1632  *
// 1633  * @return  SUCCESS or FAILURE
// 1634  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1635 uint8 GAPBondMgr_CheckNVLen( uint8 id, uint8 len )
GAPBondMgr_CheckNVLen:
        CODE
// 1636 {
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
        ; Saved register size: 10
        ; Auto size: 0
        MOV     A,R2
        MOV     R4,A
// 1637   uint8 stat = FAILURE;
        MOV     R5,#0x1
// 1638 
// 1639   // Convert to index
// 1640   switch ( (id - BLE_NVID_GAP_BOND_START) % GAP_BOND_REC_IDS )
        MOV     A,R1
        ADD     A,#-0x20
        MOV     R0,A
        CLR     A
        ADDC    A,#-0x1
        MOV     R1,A
        MOV     R2,#0x6
        MOV     R3,#0x0
        LCALL   ?S_DIV_MOD
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     R0,#?V0 + 0
        LCALL   ?US_SWITCH_DENSE
`?<Jumptable for GAPBondMgr_CheckNVLen>_0`:
        DATA
        DATA16
        DATA
        DATA16
        DW        0
        DATA
        DATA8
        DATA
        DATA8
        DB        5
        DATA
        DATA16
        DATA
        DATA16
        DW        ??GAPBondMgr_CheckNVLen_0
        DATA
        DATA16
        DATA
        DATA16
        DW        ??GAPBondMgr_CheckNVLen_1
        DATA
        DATA16
        DATA
        DATA16
        DW        ??GAPBondMgr_CheckNVLen_2
        DATA
        DATA16
        DATA
        DATA16
        DW        ??GAPBondMgr_CheckNVLen_2
        DATA
        DATA16
        DATA
        DATA16
        DW        ??GAPBondMgr_CheckNVLen_3
        DATA
        DATA16
        DATA
        DATA16
        DW        ??GAPBondMgr_CheckNVLen_3
        DATA
        DATA16
        DATA
        DATA16
        DW        ??GAPBondMgr_CheckNVLen_4
        CODE
// 1641   {
// 1642     case GAP_BOND_REC_ID_OFFSET:
// 1643       if ( len == sizeof ( gapBondRec_t ) )
??GAPBondMgr_CheckNVLen_1:
        MOV     A,#0xe
        SJMP    ??GAPBondMgr_CheckNVLen_5
// 1644       {
// 1645         stat = SUCCESS;
// 1646       }
// 1647       break;
// 1648 
// 1649     case GAP_BOND_LOCAL_LTK_OFFSET:
// 1650     case GAP_BOND_DEV_LTK_OFFSET:
// 1651       if ( len == sizeof ( gapBondLTK_t ) )
??GAPBondMgr_CheckNVLen_2:
        MOV     A,#0x1b
        SJMP    ??GAPBondMgr_CheckNVLen_5
// 1652       {
// 1653         stat = SUCCESS;
// 1654       }
// 1655       break;
// 1656 
// 1657     case GAP_BOND_DEV_IRK_OFFSET:
// 1658     case GAP_BOND_DEV_CSRK_OFFSET:
// 1659       if ( len == KEYLEN )
??GAPBondMgr_CheckNVLen_3:
        MOV     A,#0x10
??GAPBondMgr_CheckNVLen_5:
        XRL     A,R4
        JNZ     ??GAPBondMgr_CheckNVLen_0
        SJMP    ??GAPBondMgr_CheckNVLen_6
// 1660       {
// 1661         stat = SUCCESS;
// 1662       }
// 1663       break;
// 1664 
// 1665     case GAP_BOND_DEV_SIGN_COUNTER_OFFSET:
// 1666       if ( len == sizeof ( uint32 ) )
??GAPBondMgr_CheckNVLen_4:
        MOV     A,#0x4
        XRL     A,R4
        JNZ     ??GAPBondMgr_CheckNVLen_0
// 1667       {
// 1668         stat = SUCCESS;
??GAPBondMgr_CheckNVLen_6:
        DEC     R5
// 1669       }
// 1670       break;
// 1671 
// 1672     default:
// 1673       break;
// 1674   }
// 1675 
// 1676   return ( stat );
??GAPBondMgr_CheckNVLen_0:
        MOV     A,R5
        MOV     R1,A
        MOV     R7,#0x2
        LJMP    ?BANKED_LEAVE_XDATA
// 1677 }
// 1678 
// 1679 /*********************************************************************
// 1680  * @fn          gapBondMgr_ProcessGATTMsg
// 1681  *
// 1682  * @brief       Process an incoming GATT message.
// 1683  *
// 1684  * @param       pMsg - pointer to received message
// 1685  *
// 1686  * @return      none
// 1687  */
// 1688 static void gapBondMgr_ProcessGATTMsg( gattMsgEvent_t *pMsg )
// 1689 {
// 1690   // Process the GATT message
// 1691   switch ( pMsg->method )
// 1692   {
// 1693     case ATT_HANDLE_VALUE_CFM:
// 1694       // Clear Service Changed flag for this client
// 1695       VOID GAPBondMgr_ServiceChangeInd( pMsg->connHandle, 0x00 );
// 1696       break;
// 1697 
// 1698     default:
// 1699       // Unknown message
// 1700       break;
// 1701   }
// 1702 }
// 1703 
// 1704 /*********************************************************************
// 1705  * @fn          gapBondMgr_ProcessGATTServMsg
// 1706  *
// 1707  * @brief       Process an incoming GATT Server App message.
// 1708  *
// 1709  * @param       pMsg - pointer to received message
// 1710  *
// 1711  * @return      none
// 1712  */
// 1713 static void gapBondMgr_ProcessGATTServMsg( gattEventHdr_t *pMsg )
// 1714 {
// 1715   // Process the GATT Server App message
// 1716   switch ( pMsg->method )
// 1717   {
// 1718     case GATT_CLIENT_CHAR_CFG_UPDATED_EVENT:
// 1719       {
// 1720         gattClientCharCfgUpdatedEvent_t *pEvent = (gattClientCharCfgUpdatedEvent_t *)pMsg;
// 1721 
// 1722         VOID GAPBondMgr_UpdateCharCfg( pEvent->connHandle, pEvent->attrHandle, pEvent->value );
// 1723       }
// 1724       break;
// 1725 
// 1726     default:
// 1727       // Unknown message
// 1728       break;
// 1729   }
// 1730 }
// 1731 
// 1732 /*********************************************************************
// 1733  * @fn      gapBondMgrSendServiceChange
// 1734  *
// 1735  * @brief   Tell the GATT that a service change is needed.
// 1736  *
// 1737  * @param   pLinkItem - pointer to connection information
// 1738  *
// 1739  * @return  none
// 1740  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1741 static void gapBondMgrSendServiceChange( linkDBItem_t *pLinkItem )
gapBondMgrSendServiceChange:
        CODE
// 1742 {
        PUSH    DPL
        PUSH    DPH
        ; Saved register size: 2
        ; Auto size: 0
// 1743   VOID GATTServApp_SendServiceChangedInd( pLinkItem->connectionHandle,
// 1744                                           gapBondMgr_TaskID );
        ; Setup parameters for call to function GATTServApp_SendServiceChangedInd
        MOV     DPTR,#gapBondMgr_TaskID
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        LCALL   ??Subroutine23_0 & 0xFFFF
??CrossCallReturnLabel_39:
        LCALL   ??GATTServApp_SendServiceChangedInd?relay
// 1745 }
        LJMP    ?Subroutine3 & 0xFFFF
// 1746 
// 1747 /*********************************************************************
// 1748  * @fn      gapBondSetupPrivFlag
// 1749  *
// 1750  * @brief   Setup the GAP Privacy Flag properties.
// 1751  *
// 1752  * @param   none
// 1753  *
// 1754  * @return  none
// 1755  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1756 static void gapBondSetupPrivFlag( void )
gapBondSetupPrivFlag:
        CODE
// 1757 {
        PUSH    DPL
        PUSH    DPH
        ; Saved register size: 2
        ; Auto size: 1
        MOV     A,#-0x1
        LCALL   ?ALLOC_XSTACK8
// 1758   uint8 privFlagProp;
// 1759 
// 1760   if ( gapBondMgrBondTotal() > 1 )
        ; Setup parameters for call to function gapBondMgrBondTotal
        LCALL   ??gapBondMgrBondTotal?relay
        MOV     A,R1
        CLR     C
        SUBB    A,#0x2
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        JC      ??gapBondSetupPrivFlag_0
// 1761   {
// 1762     privFlagProp = GATT_PROP_READ;
        MOV     A,#0x2
        SJMP    ??gapBondSetupPrivFlag_1
// 1763   }
// 1764   else
// 1765   {
// 1766     privFlagProp = GATT_PROP_READ | GATT_PROP_WRITE;
??gapBondSetupPrivFlag_0:
        MOV     A,#0xa
??gapBondSetupPrivFlag_1:
        MOVX    @DPTR,A
// 1767   }
// 1768 
// 1769   // Setup the
// 1770   VOID GGS_SetParameter( GGS_PERI_PRIVACY_FLAG_PROPS, sizeof ( uint8 ), &privFlagProp );
        ; Setup parameters for call to function GGS_SetParameter
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,#0x1
        MOV     R1,#0x5
        LCALL   ??GGS_SetParameter?relay
// 1771 }
        MOV     A,#0x1
        LCALL   ?DEALLOC_XSTACK8
        LJMP    ?Subroutine3 & 0xFFFF
// 1772 
// 1773 /*********************************************************************
// 1774  * @fn      gapBondMgrAuthenticate
// 1775  *
// 1776  * @brief   Initiate authentication
// 1777  *
// 1778  * @param   connHandle - connection handle
// 1779  * @param   addrType - peer address type
// 1780  * @param   pPairReq - Enter these parameters if the Pairing Request was already received.
// 1781  *          NULL, if waiting for Pairing Request or if initiating.
// 1782  *
// 1783  * @return  none
// 1784  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1785 static void gapBondMgrAuthenticate( uint16 connHandle, uint8 addrType,
gapBondMgrAuthenticate:
        CODE
// 1786                                     gapPairingReq_t *pPairReq )
// 1787 {
        MOV     A,#-0xe
        LCALL   ?BANKED_ENTER_XDATA
        ; Saved register size: 14
        ; Auto size: 24
        MOV     A,#-0x18
        LCALL   ?ALLOC_XSTACK8
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
        MOV     ?V0 + 2,R1
        MOV     ?V0 + 0,R4
        MOV     ?V0 + 1,R5
// 1788   gapAuthParams_t params;
// 1789 
// 1790   VOID osal_memset( &params, 0, sizeof ( gapAuthParams_t ) );
        ; Setup parameters for call to function osal_memset
        MOV     R4,#0x18
        MOV     R5,#0x0
        MOV     R1,#0x0
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??osal_memset?relay
// 1791 
// 1792   // Setup the pairing parameters
// 1793   params.connectionHandle = connHandle;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,R6
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R7
        MOVX    @DPTR,A
// 1794   params.secReqs.ioCaps = gapBond_IOCap;
        MOV     DPTR,#gapBond_IOCap
        MOVX    A,@DPTR
        PUSH    A
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        POP     A
        MOVX    @DPTR,A
// 1795   params.secReqs.oobAvailable = gapBond_OOBDataFlag;
        MOV     DPTR,#gapBond_OOBDataFlag
        MOVX    A,@DPTR
        PUSH    A
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        POP     A
        MOVX    @DPTR,A
// 1796   params.secReqs.maxEncKeySize = gapBond_KeySize;
        MOV     DPTR,#gapBond_KeySize
        MOVX    A,@DPTR
        PUSH    A
        MOV     A,#0x17
        LCALL   ?XSTACK_DISP0_8
        POP     A
        MOVX    @DPTR,A
// 1797 
// 1798   params.secReqs.keyDist.sEncKey = (gapBond_KeyDistList & GAPBOND_KEYDIST_SENCKEY) ? TRUE : FALSE;
        MOV     A,#0x15
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ANL     A,#0xfe
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPTR,#gapBond_KeyDistList
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.0
        CLR     A
        RLC     A
        MOV     R2,A
        MOV     A,R0
        ORL     A,R2
        MOV     R0,A
        MOV     A,#0x15
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?Subroutine14 & 0xFFFF
// 1799   params.secReqs.keyDist.sIdKey = (gapBond_KeyDistList & GAPBOND_KEYDIST_SIDKEY) ? TRUE : FALSE;
??CrossCallReturnLabel_19:
        MOV     C,0xE0 /* A   */.1
        JNC     ??gapBondMgrAuthenticate_0
        SETB    B.0
        SJMP    ??gapBondMgrAuthenticate_1
??gapBondMgrAuthenticate_0:
        CLR     B.0
??gapBondMgrAuthenticate_1:
        MOV     A,R0
        ANL     A,#0xfd
        MOV     R2,A
        MOV     C,B.0
        CLR     A
        RLC     A
        RLC     A
        MOV     R0,A
        MOV     A,R2
        ORL     A,R0
        MOV     R0,A
        MOV     A,#0x15
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?Subroutine14 & 0xFFFF
// 1800   params.secReqs.keyDist.mEncKey = (gapBond_KeyDistList & GAPBOND_KEYDIST_MENCKEY) ? TRUE : FALSE;
??CrossCallReturnLabel_20:
        MOV     C,0xE0 /* A   */.3
        JNC     ??gapBondMgrAuthenticate_2
        SETB    B.0
        SJMP    ??gapBondMgrAuthenticate_3
??gapBondMgrAuthenticate_2:
        CLR     B.0
??gapBondMgrAuthenticate_3:
        MOV     A,R0
        ANL     A,#0xf7
        MOV     R2,A
        MOV     C,B.0
        CLR     A
        RLC     A
        MOV     ?V0 + 4,A
        MOV     ?V0 + 5,#0x0
        MOV     A,#0x3
        MOV     R0,#?V0 + 4
        LCALL   ?S_SHL
        LCALL   ?Subroutine18 & 0xFFFF
??CrossCallReturnLabel_31:
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?Subroutine14 & 0xFFFF
// 1801   params.secReqs.keyDist.mIdKey = (gapBond_KeyDistList & GAPBOND_KEYDIST_MIDKEY) ? TRUE : FALSE;
??CrossCallReturnLabel_21:
        MOV     C,0xE0 /* A   */.4
        JNC     ??gapBondMgrAuthenticate_4
        SETB    B.0
        SJMP    ??gapBondMgrAuthenticate_5
??gapBondMgrAuthenticate_4:
        CLR     B.0
??gapBondMgrAuthenticate_5:
        MOV     A,R0
        ANL     A,#0xef
        MOV     R2,A
        MOV     C,B.0
        CLR     A
        RLC     A
        MOV     ?V0 + 4,A
        MOV     A,#0x4
        MOV     R0,#?V0 + 4
        LCALL   ?S_SHL
        LCALL   ?Subroutine18 & 0xFFFF
??CrossCallReturnLabel_32:
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?Subroutine14 & 0xFFFF
// 1802   params.secReqs.keyDist.mSign = (gapBond_KeyDistList & GAPBOND_KEYDIST_MSIGN) ? TRUE : FALSE;
??CrossCallReturnLabel_22:
        MOV     C,0xE0 /* A   */.5
        JNC     ??gapBondMgrAuthenticate_6
        SETB    B.0
        SJMP    ??gapBondMgrAuthenticate_7
??gapBondMgrAuthenticate_6:
        CLR     B.0
??gapBondMgrAuthenticate_7:
        MOV     A,R0
        ANL     A,#0xdf
        MOV     R2,A
        MOV     C,B.0
        CLR     A
        RLC     A
        MOV     ?V0 + 4,A
        MOV     A,#0x5
        MOV     R0,#?V0 + 4
        LCALL   ?S_SHL
        LCALL   ?Subroutine18 & 0xFFFF
??CrossCallReturnLabel_33:
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?Subroutine14 & 0xFFFF
// 1803   params.secReqs.keyDist.sSign = (gapBond_KeyDistList & GAPBOND_KEYDIST_SSIGN) ? TRUE : FALSE;
??CrossCallReturnLabel_23:
        MOV     C,0xE0 /* A   */.2
        JNC     ??gapBondMgrAuthenticate_8
        SETB    B.0
        SJMP    ??gapBondMgrAuthenticate_9
??gapBondMgrAuthenticate_8:
        CLR     B.0
??gapBondMgrAuthenticate_9:
        MOV     A,R0
        ANL     A,#0xfb
        MOV     R2,A
        MOV     C,B.0
        CLR     A
        RLC     A
        MOV     ?V0 + 4,A
        MOV     A,#0x2
        MOV     R0,#?V0 + 4
        LCALL   ?S_SHL
        LCALL   ?Subroutine18 & 0xFFFF
??CrossCallReturnLabel_34:
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1804 
// 1805   // Is bond manager setup for OOB data?
// 1806   if ( gapBond_OOBDataFlag )
        MOV     DPTR,#gapBond_OOBDataFlag
        MOVX    A,@DPTR
        JZ      ??gapBondMgrAuthenticate_10
// 1807   {
// 1808     VOID osal_memcpy( params.secReqs.oob, gapBond_OOBData, KEYLEN );
        ; Setup parameters for call to function osal_memcpy
        MOV     ?V0 + 4,#0x10
        MOV     R0,#?V0 + 4
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     R4,#gapBond_OOBData & 0xff
        MOV     R5,#(gapBond_OOBData >> 8) & 0xff
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??osal_memcpy?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
// 1809   }
// 1810 
// 1811   if ( gapBond_Bonding && addrType != ADDRTYPE_PUBLIC )
??gapBondMgrAuthenticate_10:
        MOV     DPTR,#gapBond_Bonding
        MOVX    A,@DPTR
        JZ      ??gapBondMgrAuthenticate_11
        MOV     A,?V0 + 2
        JZ      ??gapBondMgrAuthenticate_12
// 1812   {
// 1813     // Force a slave ID key
// 1814     params.secReqs.keyDist.sIdKey = TRUE;
        MOV     A,#0x15
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ORL     A,#0x2
        MOVX    @DPTR,A
??gapBondMgrAuthenticate_12:
        MOV     R0,#0x1
        SJMP    ??gapBondMgrAuthenticate_13
// 1815   }
??gapBondMgrAuthenticate_11:
        MOV     R0,#0x0
??gapBondMgrAuthenticate_13:
        MOV     A,#0x14
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ORL     A,R0
        MOVX    @DPTR,A
// 1816 
// 1817   params.secReqs.authReq |= (gapBond_Bonding) ? SM_AUTH_STATE_BONDING : 0;
// 1818   params.secReqs.authReq |= (gapBond_MITM) ? SM_AUTH_STATE_AUTHENTICATED : 0;
        MOV     DPTR,#gapBond_MITM
        MOVX    A,@DPTR
        JZ      ??gapBondMgrAuthenticate_14
        MOV     R0,#0x4
        SJMP    ??gapBondMgrAuthenticate_15
??gapBondMgrAuthenticate_14:
        MOV     R0,#0x0
??gapBondMgrAuthenticate_15:
        MOV     A,#0x14
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ORL     A,R0
        MOVX    @DPTR,A
// 1819 
// 1820   VOID GAP_Authenticate( &params, pPairReq );
        ; Setup parameters for call to function GAP_Authenticate
        MOV     R4,?V0 + 0
        MOV     R5,?V0 + 1
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??GAP_Authenticate?relay
// 1821 }
        MOV     A,#0x18
        LJMP    ?Subroutine2 & 0xFFFF

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine18:
        MOV     A,R2
        ORL     A,?V0 + 4
        MOV     R0,A
        MOV     A,#0x15
        RET

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine14:
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        MOV     DPTR,#gapBond_KeyDistList
        MOVX    A,@DPTR
        RET
// 1822 
// 1823 #if ( HOST_CONFIG & PERIPHERAL_CFG )
// 1824 /*********************************************************************
// 1825  * @fn      gapBondMgrSlaveSecurityReq
// 1826  *
// 1827  * @brief   Send a slave security request
// 1828  *
// 1829  * @param   connHandle - connection handle
// 1830  *
// 1831  * @return  none
// 1832  */
// 1833 static void gapBondMgrSlaveSecurityReq( uint16 connHandle )
// 1834 {
// 1835   uint8 authReq = 0;
// 1836 
// 1837   authReq |= (gapBond_Bonding) ? SM_AUTH_STATE_BONDING : 0;
// 1838   authReq |= (gapBond_MITM) ? SM_AUTH_STATE_AUTHENTICATED : 0;
// 1839 
// 1840   VOID GAP_SendSlaveSecurityRequest( connHandle, authReq );
// 1841 }
// 1842 #endif
// 1843 
// 1844 /*********************************************************************
// 1845  * @fn      gapBondMgrBondReq
// 1846  *
// 1847  * @brief   Initiate a GAP bond request
// 1848  *
// 1849  * @param   connHandle - connection handle
// 1850  * @param   idx - NV index of bond entry
// 1851  * @param   stateFlags - bond state flags
// 1852  * @param   role - master or slave role
// 1853  * @param   startEncryption - whether or not to start encryption
// 1854  *
// 1855  * @return  none
// 1856  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1857 static void gapBondMgrBondReq( uint16 connHandle, uint8 idx, uint8 stateFlags,
gapBondMgrBondReq:
        CODE
// 1858                                uint8 role, uint8 startEncryption )
// 1859 {
        MOV     A,#-0xd
        LCALL   ?BANKED_ENTER_XDATA
        ; Saved register size: 13
        ; Auto size: 27
        MOV     A,#-0x1b
        LCALL   ?ALLOC_XSTACK8
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
        MOV     ?V0 + 1,R4
        MOV     ?V0 + 2,R5
        MOV     A,#0x28
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 4,A
// 1860   smSecurityInfo_t ltk;
// 1861   osalSnvId_t      nvId;
// 1862 
// 1863   if ( role == GAP_PROFILE_CENTRAL )
        MOV     B,#0x6
        MOV     A,R1
        MUL     AB
        MOV     R0,A
        MOV     A,#0x8
        XRL     A,?V0 + 2
        JNZ     ??gapBondMgrBondReq_0
// 1864   {
// 1865     nvId = devLTKNvID( idx );
        MOV     A,#0x22
        SJMP    ??gapBondMgrBondReq_1
// 1866   }
// 1867   else
// 1868   {
// 1869     nvId = localLTKNvID( idx );
??gapBondMgrBondReq_0:
        MOV     A,#0x21
??gapBondMgrBondReq_1:
        ADD     A,R0
        MOV     ?V0 + 3,A
// 1870   }
// 1871 
// 1872   // Initialize the NV structures
// 1873   VOID osal_memset( &ltk, 0, sizeof ( smSecurityInfo_t ) );
        ; Setup parameters for call to function osal_memset
        MOV     R4,#0x1b
        MOV     R5,#0x0
        MOV     R1,#0x0
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??osal_memset?relay
// 1874 
// 1875   if ( osal_snv_read( nvId, sizeof ( smSecurityInfo_t ), &ltk ) == SUCCESS )
        ; Setup parameters for call to function osal_snv_read
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,#0x1b
        MOV     R1,?V0 + 3
        LCALL   ??osal_snv_read?relay
        MOV     A,R1
        JNZ     ??gapBondMgrBondReq_2
// 1876   {
// 1877     if ( (ltk.keySize >= MIN_ENC_KEYSIZE) && (ltk.keySize <= MAX_ENC_KEYSIZE) )
        MOV     A,#0x1a
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ADD     A,#-0x7
        CLR     C
        SUBB    A,#0xa
        JNC     ??gapBondMgrBondReq_2
// 1878     {
// 1879       VOID GAP_Bond( connHandle,
// 1880                     ((stateFlags & GAP_BONDED_STATE_AUTHENTICATED) ? TRUE : FALSE),
// 1881                     &ltk, startEncryption );
        ; Setup parameters for call to function GAP_Bond
        MOV     A,?V0 + 4
        MOV     ?V0 + 3,A
        MOV     R0,#?V0 + 3
        LCALL   ?PUSH_XSTACK_I_ONE
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     A,?V0 + 1
        MOV     C,0xE0 /* A   */.0
        CLR     A
        RLC     A
        MOV     R1,A
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   ??GAP_Bond?relay
        MOV     A,#0x1
        LCALL   ?DEALLOC_XSTACK8
// 1882     }
// 1883   }
// 1884 }
??gapBondMgrBondReq_2:
        MOV     A,#0x1b
        LJMP    ?Subroutine5 & 0xFFFF
// 1885 
// 1886 /*********************************************************************
// 1887  * @fn      gapBondMgr_SyncWhiteList
// 1888  *
// 1889  * @brief   syncronize the White List with the bonds
// 1890  *
// 1891  * @param   none
// 1892  *
// 1893  * @return  none
// 1894  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1895 static void gapBondMgr_SyncWhiteList( void )
gapBondMgr_SyncWhiteList:
        CODE
// 1896 {
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
        ; Saved register size: 9
        ; Auto size: 0
// 1897   //erase the White List
// 1898   VOID HCI_LE_ClearWhiteListCmd();
        ; Setup parameters for call to function HCI_LE_ClearWhiteListCmd
        LCALL   ??HCI_LE_ClearWhiteListCmd?relay
// 1899 
// 1900   // Write bond addresses into the White List
// 1901   for( uint8 i = 0; i < GAP_BONDINGS_MAX; i++)
        MOV     ?V0 + 0,#0x0
// 1902   {
// 1903     // Make sure empty addresses are not added to the White List
// 1904     if ( osal_isbufset( bonds[i].publicAddr, 0xFF, B_ADDR_LEN ) == FALSE )
??gapBondMgr_SyncWhiteList_0:
        MOV     A,?V0 + 0
        MOV     B,#0xe
        MUL     AB
        MOV     R0,A
        MOV     R1,B
        MOV     A,#bonds & 0xff
        ADD     A,R0
        MOV     R6,A
        MOV     A,#(bonds >> 8) & 0xff
        ADDC    A,R1
        MOV     R7,A
        ; Setup parameters for call to function osal_isbufset
        MOV     R4,#0x6
        MOV     R1,#-0x1
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   ??osal_isbufset?relay
        MOV     A,R1
        JNZ     ??gapBondMgr_SyncWhiteList_1
// 1905     {
// 1906       VOID HCI_LE_AddWhiteListCmd( HCI_PUBLIC_DEVICE_ADDRESS, bonds[i].publicAddr );
        ; Setup parameters for call to function HCI_LE_AddWhiteListCmd
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        MOV     R1,#0x0
        LCALL   ??HCI_LE_AddWhiteListCmd?relay
// 1907     }
// 1908   }
??gapBondMgr_SyncWhiteList_1:
        INC     ?V0 + 0
        MOV     A,?V0 + 0
        CLR     C
        SUBB    A,#0xa
        JC      ??gapBondMgr_SyncWhiteList_0
// 1909 }
        LJMP    ??Subroutine22_0 & 0xFFFF
// 1910 
// 1911 /*********************************************************************
// 1912  * @fn          gapBondMgr_SyncCharCfg
// 1913  *
// 1914  * @brief       Update the Bond Manager to have the same configurations as
// 1915  *              the GATT database.
// 1916  *
// 1917  * @param       connHandle - the current connection handle to find client configurations for
// 1918  *
// 1919  * @return      none
// 1920  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1921 static void gapBondMgr_SyncCharCfg( uint16 connHandle )
gapBondMgr_SyncCharCfg:
        CODE
// 1922 {
        MOV     A,#-0xc
        LCALL   ?BANKED_ENTER_XDATA
        ; Saved register size: 12
        ; Auto size: 5
        MOV     A,#-0x5
        LCALL   ?ALLOC_XSTACK8
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
// 1923   gattAttribute_t *pAttr;
// 1924   uint16 service;
// 1925 
// 1926   // Only attributes with attribute handles between and including the Starting
// 1927   // Handle parameter and the Ending Handle parameter that match the requested
// 1928   // attribute type and the attribute value will be returned.
// 1929 
// 1930   // All attribute types are effectively compared as 128-bit UUIDs,
// 1931   // even if a 16-bit UUID is provided in this request or defined
// 1932   // for an attribute.
// 1933   pAttr = GATT_FindHandleUUID( GATT_MIN_HANDLE, GATT_MAX_HANDLE,
// 1934                                clientCharCfgUUID, ATT_BT_UUID_SIZE, &service );
        ; Setup parameters for call to function GATT_FindHandleUUID
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        MOV     ?V0 + 2,DPL
        MOV     ?V0 + 3,DPH
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     ?V0 + 2,#0x2
        MOV     ?V0 + 3,#0x0
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     ?V0 + 2,#clientCharCfgUUID & 0xff
        MOV     ?V0 + 3,#(clientCharCfgUUID >> 8) & 0xff
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     R4,#-0x1
        MOV     R5,#-0x1
        MOV     R2,#0x1
        MOV     R3,#0x0
        LCALL   ??GATT_FindHandleUUID?relay
        MOV     A,#0x6
        LCALL   ?DEALLOC_XSTACK8
        LJMP    ??gapBondMgr_SyncCharCfg_0 & 0xFFFF
// 1935   while ( ( pAttr != NULL ) )
// 1936   {
// 1937     uint8 len;
// 1938     uint8 attrVal[ATT_BT_UUID_SIZE];
// 1939 
// 1940     // It is not possible to use this request on an attribute that has a value
// 1941     // that is longer than 2.
// 1942     if ( GATTServApp_ReadAttr( connHandle, pAttr, service, attrVal,
// 1943                                &len, 0, ATT_BT_UUID_SIZE ) == SUCCESS )
??gapBondMgr_SyncCharCfg_1:
        ; Setup parameters for call to function GATTServApp_ReadAttr
        CLR     A
        MOV     ?V0 + 2,A
        MOV     ?V0 + 3,A
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOV     ?V0 + 2,DPL
        MOV     ?V0 + 3,DPH
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOV     ?V0 + 2,DPL
        MOV     ?V0 + 3,DPH
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     A,#0x9
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?PUSH_XSTACK8_X_TWO
        MOV     R1,#0x2
        MOV     A,R6
        MOV     R4,A
        MOV     A,R7
        MOV     R5,A
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
        LCALL   ??GATTServApp_ReadAttr?relay
        MOV     A,#0x8
        LCALL   ?DEALLOC_XSTACK8
        MOV     A,R1
        JNZ     ??gapBondMgr_SyncCharCfg_2
// 1944     {
// 1945       uint16 value = BUILD_UINT16(attrVal[0], attrVal[1]);
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R2
        ADD     A,#0x0
        MOV     ?V0 + 2,A
        CLR     A
        ADDC    A,R1
        MOV     ?V0 + 3,A
// 1946 
// 1947       if ( value != GATT_CFG_NO_OPERATION )
        MOV     A,R2
        ORL     A,?V0 + 3
        JZ      ??gapBondMgr_SyncCharCfg_2
// 1948       {
// 1949         // NV must be updated to meet configuration of the database
// 1950         VOID GAPBondMgr_UpdateCharCfg( connHandle, pAttr->handle, value );
        ; Setup parameters for call to function GAPBondMgr_UpdateCharCfg
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     DPL,R6
        MOV     DPH,R7
        LCALL   ??Subroutine24_0 & 0xFFFF
// 1951       }
// 1952     }
??CrossCallReturnLabel_49:
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
        LCALL   ??GAPBondMgr_UpdateCharCfg?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
// 1953 
// 1954     // Try to find the next attribute
// 1955     pAttr = GATT_FindNextAttr( pAttr, GATT_MAX_HANDLE, service, NULL );
??gapBondMgr_SyncCharCfg_2:
        ; Setup parameters for call to function GATT_FindNextAttr
        CLR     A
        MOV     ?V0 + 2,A
        MOV     ?V0 + 3,A
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?PUSH_XSTACK8_X_TWO
        MOV     R4,#-0x1
        MOV     R5,#-0x1
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   ??GATT_FindNextAttr?relay
        MOV     A,#0x4
        LCALL   ?DEALLOC_XSTACK8
??gapBondMgr_SyncCharCfg_0:
        MOV     ?V0 + 2,R2
        MOV     ?V0 + 3,R3
        MOV     R6,?V0 + 2
        MOV     R7,?V0 + 3
// 1956   } // while
        MOV     A,R6
        ORL     A,R7
        JZ      $+5
        LJMP    ??gapBondMgr_SyncCharCfg_1 & 0xFFFF
// 1957 }
        MOV     A,#0x5
        LJMP    ??Subroutine19_0 & 0xFFFF

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine12:
        INC     DPTR
        REQUIRE ??Subroutine24_0
        ; // Fall through to label ??Subroutine24_0

        RSEG BANKED_CODE:CODE:NOROOT(0)
??Subroutine24_0:
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        REQUIRE ??Subroutine25_0
        ; // Fall through to label ??Subroutine25_0

        RSEG BANKED_CODE:CODE:NOROOT(0)
??Subroutine25_0:
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        RET

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for gapBond_PairingMode>`:
        DATA8
        DB 1

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for gapBond_InitiateWait>`:
        DATA16
        DW 1000

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for gapBond_AutoFailReason>`:
        DATA8
        DB 5

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for gapBond_KeyDistList>`:
        DATA8
        DB 63

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for gapBond_KeySize>`:
        DATA8
        DB 16

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??GAPBondMgr_SetParameter?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    GAPBondMgr_SetParameter

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??GAPBondMgr_GetParameter?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    GAPBondMgr_GetParameter

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??GAPBondMgr_LinkEst?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    GAPBondMgr_LinkEst

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??GAPBondMgr_ResolveAddr?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    GAPBondMgr_ResolveAddr

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??GAPBondMgr_ServiceChangeInd?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    GAPBondMgr_ServiceChangeInd

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??GAPBondMgr_UpdateCharCfg?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    GAPBondMgr_UpdateCharCfg

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??GAPBondMgr_Register?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    GAPBondMgr_Register

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??GAPBondMgr_PasscodeRsp?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    GAPBondMgr_PasscodeRsp

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??GAPBondMgr_ProcessGAPMsg?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    GAPBondMgr_ProcessGAPMsg

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??gapBondMgrChangeState?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    gapBondMgrChangeState

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??gapBondMgrUpdateCharCfg?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    gapBondMgrUpdateCharCfg

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??gapBondMgrFindCharCfgItem?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    gapBondMgrFindCharCfgItem

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??gapBondMgrInvertCharCfgItem?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    gapBondMgrInvertCharCfgItem

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??gapBondMgrAddBond?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    gapBondMgrAddBond

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??gapBondMgrGetPublicAddr?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    gapBondMgrGetPublicAddr

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??gapBondMgrFindAddr?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    gapBondMgrFindAddr

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??gapBondMgrResolvePrivateAddr?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    gapBondMgrResolvePrivateAddr

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??gapBondMgrReadBonds?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    gapBondMgrReadBonds

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??gapBondMgrBondTotal?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    gapBondMgrBondTotal

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??gapBondMgrEraseAllBondings?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    gapBondMgrEraseAllBondings

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??gapBondMgrEraseBonding?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    gapBondMgrEraseBonding

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??GAPBondMgr_Init?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    GAPBondMgr_Init

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??GAPBondMgr_ProcessEvent?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    GAPBondMgr_ProcessEvent

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??GAPBondMgr_CheckNVLen?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    GAPBondMgr_CheckNVLen

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??gapBondMgrSendServiceChange?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    gapBondMgrSendServiceChange

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??gapBondSetupPrivFlag?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    gapBondSetupPrivFlag

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??gapBondMgrAuthenticate?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    gapBondMgrAuthenticate

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??gapBondMgrBondReq?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    gapBondMgrBondReq

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??gapBondMgr_SyncWhiteList?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    gapBondMgr_SyncWhiteList

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??gapBondMgr_SyncCharCfg?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    gapBondMgr_SyncCharCfg

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA8
`?<Constant {0, 0, 0, 0, 0, 0}>`:
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_f4240:
        DD 1000000

        END
// 1958 
// 1959 #endif // ( CENTRAL_CFG | PERIPHERAL_CFG )
// 1960 
// 1961 /*********************************************************************
// 1962 *********************************************************************/
// 
// 5 357 bytes in segment BANKED_CODE
//   180 bytes in segment BANK_RELAYS
//     6 bytes in segment XDATA_I
//     6 bytes in segment XDATA_ID
//    10 bytes in segment XDATA_ROM_C
//   169 bytes in segment XDATA_Z
// 
// 5 543 bytes of CODE  memory
//     6 bytes of CONST memory (+ 4 bytes shared)
//   175 bytes of XDATA memory
//
//Errors: none
//Warnings: none
